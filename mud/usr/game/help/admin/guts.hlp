~name{bebechy}
~keywords{admin}
~desc{

Jest pewna liczba komend, które pozwalają działać z programami
LPC. Jedna uwaga, w LPC "program" jest tym samy co "źródłowy plik
LPC", pojedynczy plik LPC to /usr/System/obj/wiztool.c lub
/usr/common/lib/intl_phrase.c.

Komendy i tematy pomocy:

%history         Pokazuje Twoją historię komend code/clone/compile
%clear           Czyści Twoją historię komend code/clone/compile

%clone           Klonuje wybrany obiekt
%destruct        Niszczy wybrany obiekt
%compile         Kompiluje wybrany obiekt

%od_report       Informacje na temat obiektu LPC
%list_dest       Lista usuniętych obiektów LPC
%full_rebuild    Rekompiluje wszystkie obiekty

%code            Komenda code uruchamia jakiś kod DGD
cd               Komendy związane z plikami, jak w systemie
%ed              Edytor tekstowy DGD.

%access          Pokazuje uprawnienia administracyjne
%rsrc            Pokazuje użycie zasobów
%quota           Pokazuje użycie zasobów i udziałów

%grant           Przydziela uprawnienia administracyjne
%ungrant         Usuwa uprawnienia administracyjne

demony           Demony dostarczające różnych usług MUDa

}


~name{history,%history,historia,historia komend,historia kompilacji}
~keywords{admin}
~desc{

Komenda %history bez argumentów pokazuje historię wartości zwróconych
przez komendy %code, %compile bądź %clone. Możesz również podać argument
w postaci numeru aby zobaczyć tylko jedną wartość z historii. Większość
wartości będzie pokazanych jako obiekt niż specificzna wartość. Mogą
również odnosić się do niskopoziomowych komend MUDliba jak $0, $1, $2,
itd.

}


~name{clear,%clear,czyszczenie historii}
~keywords{admin}
~desc{

Komenda %clear czyści historię komend. Zobacz %history.

}


~name{%clone,clone,klonuj,klonuj obiekt}
~keywords{admin}
~desc{

Komenda %clone klonuje obiekt i dodaje go do Twojej historii
komend. Bądź ostrożny, inaczej możesz wywołać wycieki pamięci!
Sklonowany obiekt może być określony przez nazwę obiektu bądź
numer z historii.

Zobacz %history.

}


~name{%destruct,destruct,zniszcz obiekt}
~keywords{admin}
~desc{

Komenda %destruct niszczy obiekty podane poprzez nazwę obiektu
bądź numer z historoo. Skasowanie biblioteki i rekompilacja jej może
nie być wystarczające aby w pełni zastąpić jej kod w obiektach
potomnych.

Zobacz %history i "http://phantasmal.sf.net/DGD/Kernel/Inheritance.html".

}


~name{%compile,compile,kompiluj obiekt}
~keywords{admin}
~desc{

Komenda %compile kompiluje obiekty podane jako nazwy obiektów albo
numer z historii. Skasowanie biblioteki i rekompilacja może nie być
wystarczające aby w pełni zastąpić jej kod w obiektach potomnych,
chociaż rekompilacja klonowanego powinna zaktualizować wszystkie
klony. Jeżeli obiekt jest klonowalny, skompilowany obiekt będzie
dodany do historii komendy.

Zobacz %history, "http://phantasmal.sf.net/DGD/Kernel/Inheritance.html",
%destruct i %full_rebuild.

}


~name{%code,code,uruchamianie kodu,lpc,kod lpc,kod}
~keywords{admin}
~desc{

Komenda %code uruchomi nieco kodu LPC DGD który podasz jako argument
i zwróci rezultat. Proste przykłady:

%code 3 + 7
%code destruct_object($3)
%code (\{"bob", "sam", "fred"\}) & (\{"bob", "william"\})

Ten kod będzie uruchomiony z Twojego katalogu i dlatego będzie 
działał z Twoimi uprawnieniami. Sam obiekt będzie nazwany
/usr/Ty/_code gdzie "Ty" będzie zamienione na Twoją nazwę
postaci. Jeżeli posiadasz plik nazwany /usr/Ty/include/code.h,
zostanie on dołączony przed uruchomieniem kodu. To pozwoli Tobie
deklarować zmienne i dziedziczyć z obiektu rodzica jeżeli masz
na to ochotę.

Zobacz %history i "http://phantasmal.sf.net/DGD".

}


~name{objectd report,od_report,%od_report,raport objectd}
~keywords{admin}
~desc{

Komenda %od_report pokaże wartość objectd dla wybranego obiektu
bądź zagadnienia. Może być użyta na programach LPC, na wybranym
numerze rzeczy bądź historii (zobacz %history):

%od_report /usr/System/obj/wiztool
%od_report #47
%od_report $7

W dowolnym z tych wypadków, raport poinformuje czy obiekt jest
klonowalny czy dziedziczy, czy zgłoszenie jest usunięte, nazwę,
indeks i czas kompilacji, poprzednie zgłoszenie (jeżeli jest),
zgłoszenie rodzicielskie i pliki na których program polega
(inne niż plik z bezpośrednim kodem źródłowym).

}


~name{%list_dest,list_dest,lista usunietych,lista usuniętych}
~keywords{admin}
~desc{

Użytkownicy którzy nie debuggują objectd prawdopodonie nigdy nie
będą potrzebowali użycia komendy %list_dest. To po prostu pokazuje
obecną listę programów, których najnowsze zgłoszenia zostały
usunięte (przy pomocy komendy %destruct albo destruct_object()),

}


~name{~enUS{rebuild,full_rebuild,%full_rebuild,full rebuild,fullrebuild,
            full_recompile,%full_recompile,full recompile,fullrecompile}}
~keywords{admin}
~desc{
  ~enUS{

The %full_rebuild command will entirely recompile the LPC sources of the
MUD with the exception of the Driver object, /kernel/sys/driver.c.
That may be separately recompiled with the %compile command if you're
so inclined.

It updates by destructing every library (as with the %destruct command) and
then rebuilding every clonable.

}}


~name{~enUS{cd,pwd,ls,cp,mv,rm,mkdir,rmdir}}
~keywords{admin}
~desc{
  ~enUS{

The cd, pwd, ls, cp, mv, rm, mkdir and rmdir commands work like in
Unix.  For DOS folks, the differences are that cd, typed by itself,
switches to your home directory instead of printing the current
directory.  pwd, typed by itself, shows the current directory.  DIR is
ls, COPY is cp, MOVE is mv.  The rest should be the same.

If you've never used either DOS or Unix, please avoid these commands
for your own sanity.  They can do serious damage to your MUD without
you intending anything bad.  If you don't understand them already,
don't use them.

}}


~name{~enUS{%ed,ed,edit}}
~keywords{admin}
~desc{
  ~enUS{

DGD includes a build-in line editor called "ed".  You invoke it by
typing "%ed", or "%ed <filename>".  This can seriously mess stuff up.
If you don't already know how to use it, please don't mess with it.

}}


~name{~enUS{%grant,%ungrant,grant,ungrant}}
~keywords{admin}
~desc{
  ~enUS{

%grant <username> access
%grant <username> <path> [read|write|full]
%grant global <path>

%ungrant <username> access
%ungrant <username> <path>
%ungrant global <path>

Using the "%grant <user> access" syntax turns a regular user into an
admin character, giving him significant additional powers.  There's no
simple, controlled way to do so at this point -- you're definitely
compromising the security of the MUD if you don't trust the person you
do this to.

The "%grant <user> <path> [r|w|f]" syntax grants a specific user a
specific kind of access (read access, write access or full
administrative access) to a specific location and all its
subdirectories.  This is the basic way that Kernel library permissions
work.

The %ungrant command is the opposite of grant, and the corresponding
syntaxes remove the corresponding permissions.  For instance "%ungrant
<user> access" will make the targeted character stop being an admin
character.  Be warned that an unscrupulous user can do that to your
character as well!

Regardless of anything else you do, the "admin" character retains full
privileges.  This is an immutable characteristic of the Kernel
Library.

}}


~name{~enUS{permission,permissions}}
~keywords{admin}
~desc{
  ~enUS{

To view a user's permissions, use the %access command.  To add new
permissions, use the %grant command.  To remove existing permissions,
use the %ungrant command.

}}
