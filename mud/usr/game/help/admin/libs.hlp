~name{biblioteka room,room library,room lib,ROOM}
~keywords{admin}
~desc{

Biblioteka room jest dziedziczona przez wszystkie "pokoje". To oznacza
nie tylko pokoje w tradycyjnym sensie, ale również przenośne,
użytkowników, npc, ciała, itd. Ogólnie rzecz biorąc, kiedy tworzysz
nowy pokój, jednakże nie musisz tworzyć nowego pliku LPC dla tego
pokoju (w odróżnieniu od większości MUDów), używasz w tym celu systemu
OnLine Creation (OLC) albo/i ręcznej edycji pliku zone[numer].unq.

Jeżeli jednak chcesz stworzyć nowy rodzaj pokoju (na przykład taki
z wolno opadającym sufitem), musisz utworzyć nowy program LPC
dziedziczący z ROOM i ustawić parser UNQ aby rozpoznawał Twój nowy
typ pokoju. Wykonasz to następująco:

1) Utwórz nowy plik LPC który będzie dziedziczyć z ROOM i UNQABLE.
ROOM będzie stałą która zawiera nazwę pliku z biblioteką room,
najprawdopodobniej /usr/common/lib/room.

2) Nadpisz funkcje create(), upgraded(), destructed(), to_unq_text()
oraz from_dtd_unq(). Te funkcje powinny wyglądać następująco (pobrane
z pliku simple_room.c):

static void create(varargs int clone) \{
  room::create(clone);
  unq::create(clone);
  if(clone) \{
    bdesc = PHR("a room");
    gdesc = PHR("a room");
    ldesc = PHR("You see a room here.");
    edesc = nil;

    MAPD->add_room_object(this_object());
  \}
\}

void destructed(int clone) \{
  room::destructed(clone);
  unq::destructed(clone);
  if(clone) \{
    MAPD->remove_room_object(this_object());
  \}
\}

void upgraded(varargs int clone) \{
  room::upgraded(clone);
  unq::upgraded(clone);
\}
 
/* Prevent anyone from getting a room */
string can_get(object mover, object new_env) \{
  return "You can't move a room!";
\}
 
string to_unq_text(void) \{
  return "\~my_room\{\\n" + to_unq_flags() + "\}\\n";
\}
 
void from_dtd_unq(mixed* unq) \{
  int ctr;
 
  if(unq[0] != "my_room")
    error("Doesn't look like room data!");
 
  for (ctr = 0; ctr < sizeof(unq[1]); ctr++) \{
    from_dtd_tag(unq[1][ctr][0], unq[1][ctr][1]);
  \}
\}

Gdzie "my_room" jest nazwą Twojego pokoju -- musi być unikalna i
nie może mieć nazwy jakiegokolwiek parametru pokoju -- jak location,
bdesc, parent, itd (znaczy się, nie może zawierać żadnego typu
już zapisanego w pliku room.dtd).

3) Teraz musisz dodać definicje dtd dla Twojego pokoju do room.dtd.
Najprostszą definicją jest po prostu "\~my_room:obj\{\}". "my_room"
musi być takie samo jak "my_room" wcześniej. Jeżeli chcesz dodać
jakieś nowe parametry zapisywane przez pokój, musisz dodać je do
room.dtd również. Oczywiście musisz je również odpowiednio obsłużyć
w kodzie LPC. Zobacz do pliku simple_portable.c jako przykład jak
to może działać.

4) Następnie musisz przywiązać Twój plik LPC do dtd który właśnie
skończyłeś tworzyć. Aby to zrobić, edytuj plik room_binder.unq i
dodaj nieco unq podobnego do tego poniżej:

\~bind\{
  \~tag\{my_room\}
  \~code\{/usr/common/obj/my_room\}
\}

gdzie my_room jest nazwą tagu dtd który skończyłeś tworzyć a
/usr/commn/obj/my_room jest nazwą pliku LPC zawierającego Twój
program (bez końcówki .c).

To wszystko. Jednakże nie możesz używać systemu OLC do tworzenia
obiektów tego typu, który przed chwilą stworzyłeś. Przynajmniej 
jeszcze nie. Jeżeli chcesz, musisz zaimplementować odpowiednie

FUNKCJE:

Teraz, aby zaimplementować Twoje super możliwości do tego pokoju,
istnieje kilka funkcji w bibliotece ROOM które musisz nadpisać aby
nadać swojemu pokojowi nowe właściwości. Niektóre z tych funkcji
mówią, że powinieneś wywołać funkcje z klasy bazowej; naprawdę 
powinieneś to zrobić, dla wszystkich pochodnych funkcji z klasy
bazowej, nawet jeżeli taka funkcja nic nie robi w danym momencie.
Może za to zacząć coś robić w przyszłości.

Funkcje kontrolujące poruszanie się:

string can_enter(object enter_object, int dir)
    Wywoływana zanim ciało mobka wejdzie do pokoju. enter_object
to ciało mobka, który próbuje wejść do pokoju, dir to kierunek
z którego nadchodzi. Zwróć nil jeżeli mobile może wejść do pokoju
albo string zawierający przyczynę dla której nie może, bądź co
blokuje jego wejście.

void enter(object enter_object, int dir)
    Wywoływana kiedy ciało mobka wchodzi do pokoju. enter_object
to ciało mobka, który dopiero co wszedł, dir to kierunek z którego
nadszedł. Domyślna implementacja tej funkcji informuje wszystkie
mobki w pokoju o przybyciu nowego. Dlatego proszę wywołuj funkcję
bazową, chyba że nie chcesz informować innych obecnych w pokoju o
przybyciu nowej istoty. Przy okazji: can_enter() będzie najczęściej
wywołane przed enter() ale nie zawsze! Na przykład administrator
używający komendy @goto _nie_wywoła_ funkcji can_enter. 

string can_leave(object leave_object, int dir)
    Wywoływana zanim ciało mobka opóści pokój. leav_object to
ciało mobka, który próbuje wyjść z pokoju, dir to kierunek w 
którym próbuje wyjść. Zwróć nil jeżeli mobile może wyjść z pokoju
albo string zawierający przyczynę dla której nie może, bądź co
blokuje jego wyjście.

void leave(object leave_object, int dir)
    Wywoływana kiedy ciało mobka opuszcza pokój. leave_object to
ciało mobka, który dopiero co wyszedł, dir to kierunek w którym
wyszedł. Domyślna implementacja tej funkcji informuje wszystkie
mobki w pokoju o opuszczeniu go przez leave_object. Dlatego proszę
wywołuj funkcję bazową, chyba że nie chcesz informować innych
obecnych w pokoju o tym, że ktoś go opuścił. Przy okazji: can_leave()
będzie _najczęściej_ wywołana przed leave() ale nie zawsz! Na przykład,
administrator używający komendy @goto _nie wywoła_ funkcji can_leave.

Funkcje podnoszenia/upuszczania/itd:

string can_remove(object mover, object movee, object new_env)
    Wywoływana zanim obiekt jest brany z tego pokoju przez komendę
bądź coś podobnego. mover to obiekt, który próbuje poruszyć obiektem,
movee jest to obiekt poruszany a new_env to obiekt to pokój do
którego ten obiekt będzie poruszony. Zwróć string z przyczyną dlaczego
obiekt nie może być usunięty albo nil aby zezwolić na przeniesienie
obiektu. Przy okazji: new_env zawsze będzie rodzicem albo potomkiem
obecnego pokoju a movee będzie zawsze potomkiem obecnego pokoju,
jednakże mover nie musi mieć jakichkolwiek relacji z pokojem.

void remove(object mover, object movee, object new_env)
    Wywoływana kiedy obiekt jest wzięty z tego pokoju przy pomocy komendy
bądź czegoś podobnego. mover to obiekt który porusza wybranym
obiektem, movee to obiekt który będzie poruszany a new_env to pokój
do którego obiekt będzie przeniesiony. Przy okazji: new_env zawsze
będzie rodzicem bądź potomkiem obecnego pokoju a movee zawsze będzie
potomkiem pokoju, jednakże mover nie musi mieć jakichkolwiek relacji
z pokojem.

string can_put(object mover, object movee, object old_env)
    Wywoływana zanim obiekt jest włożony do tego pokoju, przy pomocy
komendy bądź czegoś podobnego. mover to obiekt który próbuje włożyć
obiekt, movee to obiekt wkładany a old_env to pokój z którego obiekt
będzie brany. Zwróć przyczynę (w postaci stringa) kiedy obiekt nie
może być włożony albo nil kiedy obiekt może być przeniesiony. Przy
okazji: old_env zawsze będzie rodzicem bądź potomkiem obecnego pokoju
a movee zawsze będzie potomkiem old_env, jednakże mover nie musi mieć
jakichkolwiek relacji z pokojem.

string put(object mover, object movee, object old_env)
    Wywyływana kiedy obiekt jest wkładany do pokoju przy pomocy
komendy bądź czegoś podobnego. mover to obiekt który wkłada rzecz,
movee to wkładana rzecz a old_env to pokój z którego obiekt jest
wkładany. Przy okazji: old_env będzie zawsze rodzicem bądź potomkiem
obecnego pokoju a movee zawsze potomkiem old_env, jednakże movee
nie musi mieć jakichkolwiek relacji z pokojem.

string can_get(object mover, object new_env)
    Wywoływana kiedy ktoś próbuje wziąć ten obiekt przy pomocy
komendy lub czegoś podobnego. mover to obiekt który próbuje
poruszyć obiektem a new_env to pokój do którego ten obiekt będzie
włożony. Zwróć przyczynę (w postaci stringa) dlaczego ten obiekt
nie może być poruszony albo nil aby zezwolić na ruch. Przy okazji:
Domyślnie ta funkcja sprawdza czy obiekt nie jest detalem i zabrania
poruszenia jego jeżeli jest. Dlatego staraj się zawsze wywoływać
funckję bazową.

void get(object mover, object new_env)
    Wywoływana kiedy ktoś porusza tym obiektem przy pomocy komendy
bądź czegoś podobnego. mover to obiekt który porusza obiektem a
new_env to pokój do którego ten obiekt jest przenoszony.
}

~name{~enUS{mobile library,mobile lib,MOBILE,mob lib,mob library}}
~keywords{admin}
~desc{
  ~enUS{

Mobiles are the LPC code which serves as a go between between the 
user object and (will) control NPCs.  All sentient objects have a 
mobile, and all mobiles will normally have a body.  To create a NPC, 
you will derive an object form MOBILE.  Since no NPCs have ever been 
created yet, exactly how this will work is somewhat unclear, however 
the MOBILE library is at a state where it _should_be possible to
create a working NPC by deriving a new LPC program from MOBILE.
There are no cookbook answers here, however so you'll need to do
a little experimentation, and really understand some fundementals of
Phantasmal by the time you finish -- you'll probably also need to
modify some other files too.  If you still want to do this,
check out user_mobile.c, for an example of how to create a mobile
based on the MOBILE library (user_mobile.c is the mobile object
for a user).

When NPCs actually work, these are the functions you'll use to
control them:

void say(string msg)
     Say msg to everyone in the current room.

void emote(string msg)
     Emote something, which will be picked up by everyone in the
current room.

int whisper(object to, string str)
     Whisper "str" to "to".  "to" must be the body of a mobile in
the current room.  When something is whispered, only the person who 
is being whispered to will be able to tell what you said, however 
everyone in the same room as you will be able to tell that you 
whispered something to them.  Returns 1 if the whisper suceeded, 0 
if it failed.

int ask(object to, string str)
     Ask "to" "str".  "to" must be the body of a mobile in the
current room.  "to" can be nil, in which case the question will be
asked of everyone in the room.  Although a question can be directed
at a specific person, everyone in the room will be able to hear it.

string place(object obj, object to)
     Moves the object "obj" from its current location into "to".
Both obj and to must be descendents of your location.  String will
be a string explaining why the move failed, or nil if it succeeded.

string move(int dir)
     Moves in the direction "dir".  If the move succeeds, this 
function returns nil, otherwise it returns a string indicating
why it failed.

string teleport(object loc, int force)
     Teleports into the room "loc".  If force is 1, the teleport will
always succeed.  NB:  force will be made priviledged, and the entire
function may be made privileged, as it is a very dangerous function,
with much potential for being abused.

Here are the functions which will allow you to respond to events in
your NPCs:

void hook_say(mixed *args)
     Someone in the current room said something.  args[0] is the body
of the person who said it, and args[1] is what they said.

void hook_whisper(mixed *args)
     Someone in the current room whispered something to this mobile.
args[0] is the person who did the whispering, and args[1] is what 
they whispered.

void hook_whisper_other(mixed *args)
     Someone in the current room whispered something to someone
else in the room.  args[0] is the person who whispered, args[1] is
the person they whispered to.

void hook_ask(mixed *args)
     Someone in the current room asked you something.  args[0] is
the person who asked, and args[1] is what they asked.

void hook_ask_other(mixed *args)
     Someone in the current room asked someone in the room something.
args[0] is the person who asked, args[1] is the person they asked
(which may be nil for a general ask), and args[2] is what they asked.

void hook_leave(mixed *args)
     Someone just left this room.  args[0] is the person who left,
args[1] is the direction in which they left.

void hook_enter(mixed *args)
     Someone just entered this room.  args[0] is the person who
entered, args[1] is the direction they entered from.

}}
