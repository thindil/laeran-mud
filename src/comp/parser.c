#ifndef lint
#if 0
static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#else
static char yyrcsid[] = "$NetBSD: skeleton.c,v 1.10 1996/03/25 00:36:18 mrg Exp $";
#endif
#endif
#include <stdlib.h>
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYLEX yylex()
#define YYEMPTY -1
#define yyclearin (yychar=(YYEMPTY))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define YYPREFIX "yy"
#line 27 "parser.y"

# define INCLUDE_CTYPE
# include "comp.h"
# include "str.h"
# include "array.h"
# include "object.h"
# include "xfloat.h"
# include "interpret.h"
# include "macro.h"
# include "token.h"
# include "ppcontrol.h"
# include "node.h"
# include "compile.h"

# define yylex		pp_gettok
# define yyerror	c_error

int nerrors;			/* number of errors encountered so far */
static int ndeclarations;	/* number of declarations */
static int nstatements;		/* number of statements in current function */
static bool typechecking;	/* does the current function have it? */

static void  t_void	(node*);
static bool  t_unary	(node*, char*);
static node *prefix	(int, node*, char*);
static node *postfix	(int, node*, char*);
static node *cast	(node*, node*);
static node *idx	(node*, node*);
static node *range	(node*, node*, node*);
static node *bini	(int, node*, node*, char*);
static node *bina	(int, node*, node*, char*);
static node *mult	(int, node*, node*, char*);
static node *mdiv	(int, node*, node*, char*);
static node *mod	(int, node*, node*, char*);
static node *add	(int, node*, node*, char*);
static node *sub	(int, node*, node*, char*);
static node *umin	(node*);
static node *lshift	(int, node*, node*, char*);
static node *rshift	(int, node*, node*, char*);
static node *rel	(int, node*, node*, char*);
static node *eq		(node*, node*);
static node *and	(int, node*, node*, char*);
static node *xor	(int, node*, node*, char*);
static node *or		(int, node*, node*, char*);
static node *land	(node*, node*);
static node *lor	(node*, node*);
static node *quest	(node*, node*, node*);
static node *assign	(node*, node*);
static node *comma	(node*, node*);

#line 94 "parser.y"
typedef union {
    Int number;			/* lex input */
    xfloat real;		/* lex input */
    unsigned short type;	/* internal */
    struct _node_ *node;	/* internal */
} YYSTYPE;
#line 77 "y.tab.c"
#define VOID 257
#define INHERIT 258
#define MAPPING 259
#define BREAK 260
#define ELSE 261
#define CASE 262
#define NIL 263
#define FOR 264
#define STATIC 265
#define CONTINUE 266
#define PRIVATE 267
#define FUNCTION 268
#define RLIMITS 269
#define RETURN 270
#define OPERATOR 271
#define FLOAT 272
#define DO 273
#define IF 274
#define OBJECT 275
#define GOTO 276
#define STRING 277
#define WHILE 278
#define NEW 279
#define VARARGS 280
#define CATCH 281
#define SWITCH 282
#define NOMASK 283
#define ATOMIC 284
#define INT 285
#define DEFAULT 286
#define MIXED 287
#define LARROW 288
#define RARROW 289
#define PLUS_PLUS 290
#define MIN_MIN 291
#define LSHIFT 292
#define RSHIFT 293
#define LE 294
#define GE 295
#define EQ 296
#define NE 297
#define LAND 298
#define LOR 299
#define PLUS_EQ 300
#define MIN_EQ 301
#define MULT_EQ 302
#define DIV_EQ 303
#define MOD_EQ 304
#define LSHIFT_EQ 305
#define RSHIFT_EQ 306
#define AND_EQ 307
#define XOR_EQ 308
#define OR_EQ 309
#define COLON_COLON 310
#define DOT_DOT 311
#define ELLIPSIS 312
#define STRING_CONST 313
#define IDENTIFIER 314
#define INT_CONST 315
#define FLOAT_CONST 316
#define MARK 317
#define HASH 318
#define HASH_HASH 319
#define INCL_CONST 320
#define NR_TOKENS 321
#define YYERRCODE 256
short yylhs[] = {                                        -1,
   57,    0,   56,   56,   58,   58,   58,    7,    7,   55,
    9,    9,    9,    8,   60,   62,   61,   63,   61,   64,
   10,   10,   10,   10,   11,   11,   12,   12,   13,   13,
    1,    1,    1,    2,    2,    3,    3,    4,    4,    5,
    5,    5,    5,   14,   14,   14,   14,   14,   14,   14,
   14,   14,   59,   59,    6,    6,   15,   16,   16,   16,
   16,   16,   16,   16,   16,   16,   16,   16,   16,   16,
   16,   16,   16,   16,   16,   16,   16,   17,   17,   18,
   19,   19,   20,   20,   21,   21,   22,   22,   22,   65,
   23,   24,   24,   24,   66,   24,   67,   24,   68,   24,
   69,   24,   70,   24,   71,   72,   24,   73,   24,   74,
   24,   75,   24,   76,   24,   77,   24,   24,   24,   24,
   24,   24,   78,   25,   26,   26,   27,   27,   27,   28,
   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
   28,   79,   28,   28,   28,   28,   28,   28,   28,   28,
   29,   29,   29,   30,   30,   30,   31,   31,   31,   31,
   31,   31,   31,   32,   32,   33,   33,   33,   33,   34,
   34,   34,   35,   35,   35,   36,   36,   36,   36,   36,
   37,   37,   37,   38,   38,   39,   39,   40,   40,   41,
   41,   42,   42,   43,   80,   81,   43,   44,   44,   44,
   44,   44,   44,   44,   44,   44,   44,   44,   44,   45,
   45,   46,   46,   47,   48,   49,   49,   50,   50,   50,
   51,   51,   51,   52,   53,   53,   54,   54,   54,
};
short yylen[] = {                                         2,
    0,    2,    0,    2,    6,    1,    1,    0,    1,    1,
    1,    3,    3,    1,    4,    0,    5,    0,    7,    4,
    0,    1,    1,    2,    1,    3,    2,    1,    2,    1,
    1,    1,    2,    1,    2,    1,    1,    0,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    2,    1,    1,
    1,    1,    0,    1,    0,    2,    2,    2,    2,    2,
    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
    2,    2,    2,    2,    3,    4,    4,    1,    1,    5,
    1,    1,    1,    3,    0,    2,    1,    1,    2,    0,
    6,    2,    1,    1,    0,    4,    0,    8,    0,    6,
    0,   10,    0,    8,    0,    0,    5,    0,    6,    0,
    5,    0,    7,    0,    4,    0,    4,    3,    2,    2,
    3,    1,    0,    4,    0,    2,    1,    2,    3,    1,
    1,    1,    1,    5,    5,    1,    3,    4,    5,    8,
    7,    0,    5,    3,    5,    6,    8,    6,    4,    6,
    1,    4,    6,    1,    2,    2,    1,    2,    2,    2,
    2,    2,    2,    1,    5,    1,    3,    3,    3,    1,
    3,    3,    1,    3,    3,    1,    3,    3,    3,    3,
    1,    3,    3,    1,    3,    1,    3,    1,    3,    1,
    3,    1,    3,    1,    0,    0,    7,    1,    3,    3,
    3,    3,    3,    3,    3,    3,    3,    3,    3,    1,
    3,    0,    1,    1,    1,    1,    3,    0,    1,    2,
    0,    1,    2,    3,    1,    3,    0,    1,    2,
};
short yydefred[] = {                                      1,
    0,    3,    0,   40,    0,   43,   42,   41,    0,    0,
    0,    0,    4,    6,    7,   52,   49,   50,   45,    0,
   46,   44,   51,   10,   55,    0,   36,    0,   34,   37,
    0,   14,    0,   11,    0,    0,   81,    0,   83,    0,
    0,   35,    0,    9,    0,    0,    0,   56,   79,    0,
    0,    0,   15,   55,    0,    0,    0,    0,   25,   28,
   55,   30,   54,    0,   13,   12,   73,   74,   70,   71,
   68,   69,   58,   60,   59,   61,   62,   63,   64,   65,
   66,   67,   72,    0,    0,  123,   17,   82,   84,   27,
   18,   24,    0,    0,   29,    0,    0,    0,    0,   85,
    0,   26,   57,    5,   77,   76,   80,    0,   19,    0,
    0,    0,  132,    0,    0,    0,    0,   97,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  130,  131,
  122,    0,    0,    0,    0,    0,  124,    0,    0,   31,
  133,    0,   86,    0,   88,   93,    0,  151,    0,    0,
  164,  166,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  210,    0,    0,   87,   89,  119,    0,
    0,    0,    0,  120,    0,    0,  215,    0,    0,    0,
    0,    0,    0,  142,    0,    0,  114,  158,  159,  128,
   78,  161,    0,    0,    0,   55,    0,  160,    0,    0,
  163,  162,   55,    0,   95,    0,    0,    0,    0,  155,
  156,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  195,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   92,    0,  116,    0,  110,    0,    0,    0,  121,
    0,    0,  118,    0,    0,    0,    0,  106,    0,    0,
    0,    0,  225,    0,    0,  216,    0,    0,    0,  137,
    0,    0,    0,  129,    0,    0,    0,    0,    0,    0,
    0,    0,  167,  168,  169,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  200,  201,  202,  203,  204,  205,  206,  207,  208,
  209,  199,  211,    0,    0,    0,    0,    0,    0,   90,
   99,    0,    0,    0,    0,  108,  115,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   20,   96,  220,    0,
  138,    0,  149,    0,  152,    0,    0,  117,  112,  111,
    0,    0,    0,    0,    0,    0,    0,  143,    0,  107,
    0,    0,  224,  226,  135,  217,  134,  165,    0,  139,
    0,    0,    0,  196,    0,    0,  103,    0,   91,  100,
    0,  146,  126,  109,    0,    0,  150,  148,  153,    0,
  113,    0,    0,    0,    0,  141,    0,  197,  101,  104,
   98,  147,  140,    0,  102,
};
short yydgoto[] = {                                       1,
    9,   28,   10,   11,   12,   36,   43,  141,   35,   57,
   58,   59,   60,   61,   37,   49,  142,   88,   39,   40,
  108,  143,  144,  145,  146,  360,  147,  148,  149,  150,
  151,  152,  153,  154,  155,  156,  157,  158,  159,  160,
  161,  162,  163,  164,  165,  177,  249,  178,  276,  277,
  268,  263,  264,  265,  172,    3,    2,   13,   64,   14,
   15,   52,  101,  167,  354,  275,  179,  355,  404,  393,
  185,  325,  361,  316,  375,  260,  314,  100,  257,  301,
  390,
};
short yysindex[] = {                                      0,
    0,    0, -202,    0,    0,    0,    0,    0,  957, -194,
 -197,    0,    0,    0,    0,    0,    0,    0,    0,  -26,
    0,    0,    0,    0,    0,   53,    0, -194,    0,    0,
 -247,    0,  -26,    0,   59,  -17,    0,    0,    0,    7,
  476,    0, -159,    0,   13, -193,   85,    0,    0,   84,
    0,    8,    0,    0,    0,  957,   96,  -28,    0,    0,
    0,    0,    0,  -26,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  -70,  476,    0,    0,    0,    0,    0,
    0,    0, 1213,  -31,    0,   -1,   69,   91,  115,    0,
    8,    0,    0,    0,    0,    0,    0,  266,    0,  109,
  119,   58,    0,  146,  138,  158,   58,    0,  160, -247,
  164, -159,  168,  173,  157,   58,   58, -227,    0,    0,
    0,   58,  520,   58,  -34,   58,    0,   58, -118,    0,
    0,  -93,    0,  -41,    0,    0,  181,    0,  -56, -119,
    0,    0,   63,   52, -103,  -36, -105,  184,  129,  100,
  -72,  -55,  135,    0,   24,  169,    0,    0,    0,  168,
  -25,    0,   58,    0,   58,  191,    0,  177,  324,   58,
  187,   58,  -21,    0,    8,   58,    0,    0,    0,    0,
    0,    0,   58,   58,   58,    0,   77,    0,  186,  209,
    0,    0,    0, -227,    0,   58, -159, -247,   58,    0,
    0,   58,   58,   58,   58,   58,   58,   58,   58,   58,
   58,   58,   58,   58,   58,   58,   58,   58,   58,    0,
   58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
   58,    0,   58,    0,   58,    0,  196,  191,  197,    0,
   -8,  228,    0,  230,  -26,  234,   58,    0,  254,  324,
  255,  217,    0,  256,  208,    0,  259,  183,  152,    0,
   58,   58,   48,    0,  324,  -14,  272,  -20,  274,  191,
  222,    5,    0,    0,    0,   63,   63,   52,   52, -103,
 -103, -103, -103,  -36,  -36, -105,  184,  129,  100,  -72,
   58,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  324,  261,  324,   58,   58,  277,    0,
    0,   99,   58,   94,  262,    0,    0,  286,   58,   58,
  291,   58,  292,   58,  293,  294,    0,    0,    0,   58,
    0,  -26,    0,   58,    0,   58,   50,    0,    0,    0,
  268,  295,   58,  324,  324,  298,  299,    0,  324,    0,
    8,   58,    0,    0,    0,    0,    0,    0,  301,    0,
  120,  302,  251,    0,  324,   58,    0,  306,    0,    0,
   58,    0,    0,    0,  311,   58,    0,    0,    0,   58,
    0,  312,    8,  296,  313,    0,  315,    0,    0,    0,
    0,    0,    0,  324,    0,
};
short yyrindex[] = {                                      0,
    0,    0,    4,    0,  801,    0,    0,    0,    0,    0,
  958,  541,    0,    0,    0,    0,    0,    0,    0,  -32,
    0,    0,    0,    0,    0,    0,    0, 1636,    0,    0,
  -35,    0,    0,    0,  -29,    0,    0,   -6,    0,    0,
  317,    0,  -19,    0,    0,    0,    0,    0,    0,    0,
   20,    0,    0,    0,  -24,    0,    0,  318,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  317,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  -33,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  477,    0,    0,
    0,    0,    0,    0,    0,    0,  304,    0,    0,    0,
    0,  -19,  237,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  321,    0,  205,    0,    0,    0,    0,  827,  955,
    0,    0,  981, 1144, 1458, 1767, 1989, 2113, 2184, 2298,
 2583, 1372,   11,    0,    0, 2219,    0,    0,    0,    0,
    0,  607,  304,    0,    0,   16,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  288,  240,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  329,  -19,    0,   71,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   21,    0,    0,
    0,    0,    0,    0,    0,  634,    0,    0,    0,    0,
    0,    0,    0,  297,    0,    0,  260,    0,    0,    0,
    0,  329,    0,    0,    0,  343,    0,    0,    0,  -64,
    0,    0,    0,    0,    0, 1049, 1103, 1269, 1416, 1495,
 1546, 1572, 1688, 1844, 1881, 2161, 2258, 2274, 2314, 2599,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  304,    0,    0,    0,
    0,    0,  329,    0,  142,    0,    0,    0,    0,  300,
    0,  263,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  329,    0,  303,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  679,    0,    0,    0,    0,
    0,  329,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  345,    0,    0,    0,    0,
  329,    0,    0,    0,    0,  329,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,
};
short yygindex[] = {                                      0,
  279,    0,   31,  289,   78,  -22,    0,  -18,  -30,  309,
    0,  307,  374,   27,  370,    0,    1,  409,  391,  243,
    0,    0,    0, -102,  -51,    0,    0,    0,    0,    0,
    0,   17,  -13,  -11, -107,   -5,  223,  225,  226,  221,
  231,    0,   64, 1886, 2520, -142, -137, -169,  264, -198,
    0,  133,    0,    0,   -9,    0,    0,    0,  -74,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,
};
#define YYTABLESIZE 2911
short yytable[] = {                                      26,
   87,   34,   45,    2,    8,  199,   75,  230,   47,   47,
   48,   48,   48,   33,   34,   93,   22,   52,  255,  342,
   53,   44,   98,  221,   48,  222,   51,   66,  214,  340,
  247,   62,  246,   96,  209,   25,   50,   82,   94,  282,
   29,   46,  252,   47,  254,   34,   62,  183,  259,  109,
   54,  198,   82,   65,  198,   46,  213,  104,   42,   78,
   31,  214,    4,   57,    5,   53,   24,  243,  198,  198,
    4,  281,   27,  336,  213,   62,  251,    6,   57,  214,
    7,    8,  242,   62,  103,    6,   24,   30,    7,    8,
  138,   54,   41,  243,  215,  135,  216,  133,  166,  214,
  132,   46,  134,  198,  212,   30,  337,  374,  213,  213,
  181,  290,  291,  292,  293,   63,   16,  270,  191,   32,
  243,   77,   78,   85,  357,  200,   74,   73,  190,   75,
   86,   76,  278,  258,  358,  198,   91,  243,   16,  356,
   17,   46,  188,  189,   81,  372,   82,  351,  192,   18,
  198,  106,  201,   19,  202,  107,   20,  327,   21,  196,
  387,  105,   46,  385,  256,  203,   22,  168,   23,  166,
  210,  211,  338,  269,  125,   84,  373,  169,   79,  125,
  352,  125,  395,  136,  125,  173,  125,  397,  217,  218,
  223,  224,  334,   48,  191,  241,  174,  175,  279,  180,
  125,  286,  287,  182,  274,  288,  289,  184,   80,  261,
   83,  348,  186,  350,  187,  378,  204,  294,  295,  205,
  206,  225,  226,  227,  322,  228,  244,  271,  283,  284,
  285,  207,  208,  392,  243,  250,   34,   94,   47,    8,
   97,   48,   94,  229,   94,  253,  213,   94,  272,   94,
  166,  379,  380,   47,  317,  318,  383,  219,  220,  343,
   38,   38,   38,   94,  125,  166,  125,  125,  320,  319,
  321,   38,  391,  323,  329,   38,   75,    8,   38,   24,
   38,   47,   24,   92,   48,  245,   32,  335,   38,   52,
   38,   32,   32,   53,  326,  328,   24,  339,  138,  330,
  331,  405,  332,  135,  166,  133,  166,  333,  132,  384,
  134,  371,  341,  344,  345,  346,  353,   38,  349,  359,
  113,  198,  198,   34,  131,  362,  376,   94,   47,   94,
   94,  365,  367,  369,  370,  377,  122,  381,  170,  382,
  386,  400,  388,  389,  166,  166,  394,  126,  127,  166,
  368,  396,  399,  402,  401,  403,  138,   21,   23,  105,
  127,  135,  212,  133,  221,  166,  132,  128,  134,  218,
   32,   24,  129,  130,   67,   68,   69,   70,   71,   72,
  227,  212,  131,  219,  222,  212,  139,  223,   86,  228,
  137,  136,  229,   99,  166,  212,  140,  125,  125,  102,
  125,  125,  125,  125,  125,  125,  125,  125,  125,  125,
  125,  125,  125,  125,  125,  125,  125,  125,  125,  125,
  125,  125,  125,  125,  125,  125,  125,  125,  125,   90,
   95,  125,  125,   38,  231,  232,  233,  234,  235,  236,
  237,  238,  239,  240,   89,  273,   86,  296,  299,  136,
  297,  125,  298,  398,  125,  125,  125,  125,  267,  300,
   94,   94,  364,   94,   94,    0,   94,   94,   94,   94,
   94,   94,   94,   94,   94,   94,   94,   94,   94,   94,
   94,   94,   94,   94,   94,   94,   94,   94,   94,   94,
   94,   94,    0,    0,   94,   94,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   94,    0,    0,   94,   94,   94,
   94,  110,    0,    0,    0,  111,    0,  112,  113,  114,
    4,  115,    5,    0,  116,  117,   47,    0,  118,  119,
    0,  120,    0,  121,  122,    6,  123,  124,    7,    8,
    0,  125,  138,    0,    0,  126,  127,  135,    0,  133,
    0,  193,  132,    0,  134,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  128,    0,    0,   32,   24,
  129,  130,    0,  111,    0,  112,  113,  114,    0,  115,
    0,    0,  116,  117,   47,    0,  118,  119,    0,  120,
    0,  121,  122,    0,  123,  124,    0,    0,    0,  125,
  194,    0,    0,  126,  127,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  128,    0,    0,   32,   24,  129,  130,
    0,    0,  195,  136,  136,  136,   78,  136,  136,  136,
  136,  136,    0,  136,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  136,  136,  136,  136,  136,  136,
  144,  144,    0,    0,  144,  144,  144,  144,  144,    0,
  144,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  144,  144,  144,  144,  144,  144,  136,    0,  136,
  136,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  145,  145,    0,    0,  145,
  145,  145,  145,  145,  144,  145,  144,  144,    0,    0,
  136,  136,   55,   38,   17,   38,  145,  145,  145,  145,
  145,  145,    0,   18,   38,    0,    0,   19,   38,    0,
   20,   38,   21,   38,    0,   56,    0,  144,  144,    0,
   22,   38,   23,   38,    0,    0,    0,    0,    0,  145,
    0,  145,  145,    0,    0,    0,   16,    0,   17,    0,
    0,    0,  113,    0,    0,    0,    0,   18,    0,   24,
   47,   19,    0,    0,   20,    0,   21,   32,  122,   32,
  170,    0,  145,  145,   22,   37,   23,   37,   32,  126,
  127,    0,   32,    0,    0,   32,    0,   32,    0,    0,
   37,    0,    0,   37,   37,   32,    0,   32,    0,  128,
    0,    0,   32,   24,  129,  130,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   32,    0,    0,    0,    0,    0,
    0,    0,    0,  154,  154,    0,    0,  154,  154,  154,
  154,  154,    0,  154,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  154,  154,  154,  154,  154,  154,
    0,    0,    0,    0,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,   78,  136,  136,  154,
  154,  144,  144,  144,  144,  144,  144,  144,  144,  144,
  144,  144,  144,  144,  144,  144,  144,  144,  144,  144,
  144,  144,  144,    0,  144,  144,    0,    0,    0,    0,
  154,  154,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  145,  145,  145,  145,
  145,  145,  145,  145,  145,  145,  145,  145,  145,  145,
  145,  145,  145,  145,  145,  145,  145,  145,    0,  145,
  145,  157,  157,    0,    0,  157,  157,  157,  157,  157,
    0,  157,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  157,  157,  157,  157,  157,  157,  170,    0,
    0,  170,    0,  170,  170,  170,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  170,  170,
  170,  170,  170,  170,    0,    0,    0,  157,  157,    0,
    0,    0,    0,    0,    0,    0,    0,   39,   39,   39,
    0,    0,    0,    0,    0,   36,    0,   36,   39,    0,
    0,    0,   39,  170,  170,   39,    0,   39,  157,  157,
   36,    0,    0,   36,   36,   39,  171,   39,    0,  171,
    0,  171,  171,  171,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  170,  170,  171,  171,  171,  171,
  171,  171,    0,    0,   39,    0,  154,  154,  154,  154,
  154,  154,  154,  154,  154,  154,  154,  154,  154,  154,
  154,  154,  154,  154,  154,  154,    0,  154,  154,    0,
  172,  171,  171,  172,    0,  172,  172,  172,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  172,  172,  172,  172,  172,  172,    0,    0,    0,    0,
    0,    0,  171,  171,    0,    0,    0,    0,    0,    0,
    0,  173,    0,    0,  173,    0,    0,  173,    0,    0,
    0,    0,    0,    0,    0,  172,  172,    0,    0,    0,
    0,  173,  173,  173,  173,  173,  173,    0,    0,    0,
    0,    0,    0,   16,   31,   17,   31,    0,    0,    0,
    0,    0,    0,    0,   18,   31,  172,  172,   19,   31,
    0,   20,   31,   21,   31,    0,  173,  173,    0,    0,
    0,   22,   31,   23,   31,    0,  157,  157,  157,  157,
  157,  157,  157,  157,  157,  157,  157,  157,  157,  157,
  157,  157,  157,  157,    0,  157,  157,  173,  173,    0,
   24,   31,  170,  170,  170,  170,  170,  170,  170,  170,
  170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
    0,  170,  170,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  174,    0,    0,  174,
    0,    0,  174,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  174,  174,  174,  174,
  174,  174,    0,    0,    0,    0,    0,    0,    0,    0,
  171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
  171,  171,  171,  171,  171,  171,  171,  171,    0,  171,
  171,  174,  174,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  174,  174,  172,  172,  172,  172,  172,  172,
  172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
  172,  172,  194,  172,  172,  194,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  194,
  194,    0,  194,    0,    0,  173,  173,  173,  173,  173,
  173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
  173,  173,  173,  175,  173,  173,  175,    0,    0,  175,
    0,    0,    0,    0,  194,    0,    0,    0,    0,   16,
    0,   17,    0,  175,  175,  175,  175,  175,  175,    0,
   18,    0,    0,    0,   19,    0,    0,   20,    0,   21,
    0,    0,   56,    0,    0,  176,  194,   22,  176,   23,
    0,  176,    0,    0,    0,    0,    0,    0,  175,  175,
    0,    0,    0,    0,    0,  176,  176,  176,  176,  176,
  176,    0,    0,    0,    0,    0,   24,    0,    0,    0,
    0,    0,  179,    0,    0,  179,    0,    0,  179,  175,
  175,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  176,  176,  179,  179,  179,  179,  179,  179,    0,    0,
  174,  174,  174,  174,  174,  174,  174,  174,  174,  174,
  174,  174,  174,  174,  174,  174,  174,  174,    0,  174,
  174,  176,  176,  180,    0,    0,  180,  179,  179,  180,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  180,  180,  180,  180,  180,  180,  177,
    0,    0,  177,    0,    0,  177,    0,    0,  179,  179,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  177,
  177,  177,  177,  177,  177,    0,    0,    0,  180,  180,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  177,  177,    0,    0,    0,  180,
  180,  194,  194,  194,  194,  194,  194,  194,  194,  194,
  194,    0,  194,  194,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  177,  177,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  175,  175,  175,
  175,  175,  175,  175,  175,  175,  175,  175,  175,  175,
  175,  175,  175,  175,  175,  178,  175,  175,  178,    0,
    0,  178,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  178,  178,  178,  178,  178,
  178,  176,  176,  176,  176,  176,  176,  176,  176,  176,
  176,  176,  176,  176,  176,  176,  176,    0,  176,  176,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  178,  178,    0,    0,    0,    0,    0,    0,  179,  179,
  179,  179,  179,  179,  179,  179,  179,  179,  179,  179,
  179,  179,  179,  179,  181,  179,  179,  181,    0,    0,
  181,  178,  178,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  181,  181,    0,  181,    0,  181,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  180,
  180,  180,  180,  180,  180,  180,  180,  180,  180,  180,
  180,  180,  180,  180,  180,    0,  180,  180,    0,  181,
  181,    0,    0,    0,    0,  177,  177,  177,  177,  177,
  177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
  177,  182,  177,  177,  182,    0,    0,  182,    0,    0,
  181,  181,   33,    0,   33,    0,    0,    0,    0,    0,
    0,  182,  182,   33,  182,    0,  182,   33,    0,    0,
   33,    0,   33,    0,    0,    0,    0,    0,  183,    0,
   33,  183,   33,    0,  183,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  182,  182,  183,  183,
    0,  183,    0,  183,    0,    0,    0,    0,    0,   33,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  182,  182,    0,
    0,    0,    0,  183,  183,    0,    0,    0,    0,    0,
    0,  178,  178,  178,  178,  178,  178,  178,  178,  178,
  178,  178,  178,  178,  178,  178,  178,  171,  178,  178,
    0,    0,    0,    0,  183,  183,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  184,    0,    0,  184,
    0,    0,  184,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  184,  184,    0,  184,
    0,  184,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  181,  181,  181,  181,  181,  181,  181,  181,
  181,  181,  181,  181,  181,  181,    0,  181,  181,  262,
  266,  184,  184,    0,    0,    0,    0,    0,    0,    0,
    0,  266,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  184,  184,    0,    0,  302,  303,  304,  305,
  306,  307,  308,  309,  310,  311,  312,    0,  313,    0,
  315,    0,    0,    0,    0,    0,    0,    0,    0,  182,
  182,  182,  182,  182,  182,  182,  182,  182,  182,  182,
  182,  182,  182,  186,  182,  182,  186,  266,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  186,  186,    0,  186,    0,  186,  183,  183,  183,  183,
  183,  183,  183,  183,  183,  183,  183,  183,  183,  183,
    0,  183,  183,    0,    0,    0,    0,    0,  185,    0,
    0,  185,    0,    0,  185,  186,  186,    0,  266,    0,
    0,    0,    0,    0,  363,  262,    0,  366,  185,  185,
    0,  185,    0,  185,  188,  366,    0,  188,    0,  266,
    0,    0,    0,    0,    0,    0,  186,  186,    0,    0,
    0,  188,  188,    0,  188,    0,  188,  266,    0,    0,
    0,    0,    0,  185,  185,  136,  136,    0,   78,    0,
  136,  136,  136,  136,    0,  136,  266,    0,    0,    0,
    0,  266,    0,    0,    0,    0,  188,  136,  136,  136,
  136,  136,    0,    0,  185,  185,  184,  184,  184,  184,
  184,  184,  184,  184,  184,  184,  184,  184,  187,  184,
  184,  187,    0,    0,    0,    0,    0,  188,  188,  136,
    0,    0,  136,    0,  189,  187,  187,  189,  187,    0,
  187,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  189,  189,    0,  189,    0,  189,    0,  190,    0,
    0,  190,  136,    0,    0,    0,    0,    0,    0,    0,
  187,  187,    0,    0,  191,  190,  190,  191,  190,    0,
  190,    0,    0,    0,    0,    0,  189,    0,    0,    0,
    0,  191,  191,    0,  191,    0,  191,    0,    0,    0,
    0,  187,  187,    0,    0,    0,    0,    0,    0,    0,
  190,    0,    0,    0,    0,    0,    0,  189,  189,    0,
    0,    0,    0,    0,    0,    0,  191,    0,    0,    0,
  186,  186,  186,  186,  186,  186,  186,  186,  186,  186,
  186,  186,  190,  186,  186,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  191,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  185,  185,
  185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
    0,  185,  185,    0,    0,    0,    0,    0,    0,    0,
    0,  188,  188,  188,  188,  188,  188,  188,  188,  188,
  188,  188,  188,    0,  188,  188,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,   78,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  187,  187,  187,  187,  187,
  187,  187,  187,  187,  187,  187,  187,    0,  187,  187,
    0,  189,  189,  189,  189,  189,  189,  189,  189,  189,
  189,  189,  189,    0,  189,  189,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  190,  190,  190,  190,  190,
  190,  190,  190,  190,  190,  190,  190,    0,  190,  190,
    0,  191,  191,  191,  191,  191,  191,  191,  191,  191,
  191,  191,  191,  192,  191,  191,  192,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  176,    0,    0,  193,
  192,  192,  193,  192,    0,  192,    0,    0,    0,    0,
    0,    0,  197,    0,    0,    0,  193,  193,    0,  193,
    0,  193,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  192,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  193,  176,    0,  248,    0,    0,    0,    0,  248,
    0,  248,    0,    0,    0,  248,    0,  192,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  193,    0,    0,    0,    0,  280,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  324,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  347,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  176,  248,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  176,    0,    0,    0,    0,
    0,    0,  248,    0,    0,    0,    0,    0,    0,    0,
    0,  192,  192,  192,  192,  192,  192,  192,  192,  192,
  192,  192,    0,  192,  192,  176,    0,  193,  193,  193,
  193,  193,  193,  193,  193,  193,  193,  193,    0,  193,
  193,
};
short yycheck[] = {                                       9,
   52,   20,   33,    0,   40,   40,   40,   63,   41,   42,
   42,   41,   42,   40,   33,   44,   41,   42,   40,   40,
   40,   31,   93,   60,   42,   62,   36,   46,   93,   44,
  173,   41,   58,   64,   91,    9,   36,   44,   61,  209,
   10,   43,  180,  271,  182,   64,   56,  122,  186,  101,
   44,   41,   59,   41,   44,   43,   41,   59,   28,   40,
  258,   41,  265,   44,  267,   59,  314,   44,   58,   59,
  265,  209,  267,  272,   59,   85,  179,  280,   59,   59,
  283,  284,   59,   93,   94,  280,  314,   10,  283,  284,
   33,   44,   40,   44,   43,   38,   45,   40,  108,   37,
   43,   43,   45,   93,   42,   28,   59,   58,   93,   47,
  120,  219,  220,  221,  222,  275,  123,   41,  128,  313,
   44,   37,   38,   40,  323,  135,   42,   43,  128,   45,
  123,   47,  207,  185,   41,  125,   41,   44,  257,   41,
  259,   43,  126,  127,   60,  344,   62,  317,  132,  268,
  134,   61,  136,  272,  138,   41,  275,  260,  277,  133,
   41,   93,   43,  362,  183,  139,  285,   59,  287,  179,
  290,  291,  275,  196,   33,   91,  346,   59,   94,   38,
  318,   40,  381,  126,   43,   40,   45,  386,  292,  293,
  296,  297,   41,   42,  204,   61,   59,   40,  208,   40,
   59,  215,  216,   40,  204,  217,  218,   40,  124,  193,
  126,  314,   40,  316,   58,  353,  310,  223,  224,  261,
   40,   38,   94,  124,  255,  298,   58,   42,  212,  213,
  214,  288,  289,  376,   44,   59,  255,   33,  271,  275,
  311,  271,   38,  299,   40,   59,  311,   43,   40,   45,
  260,  354,  355,  271,   59,   59,  359,  294,  295,  278,
  257,  258,  259,   59,  123,  275,  125,  126,   41,  278,
   41,  268,  375,   40,   58,  272,  310,  313,  275,  314,
  277,  314,  314,  312,  314,  311,  313,  271,  285,  314,
  287,  313,  313,  313,   41,   41,  314,  312,   33,   44,
   93,  404,   44,   38,  314,   40,  316,  125,   43,  361,
   45,  342,   41,   40,   93,  311,   40,  314,   58,   58,
  263,  311,  312,  342,   59,   40,   59,  123,  271,  125,
  126,   41,   41,   41,   41,   41,  279,   40,  281,   41,
   40,  393,   41,   93,  354,  355,   41,  290,  291,  359,
  334,   41,   41,   41,   59,   41,   33,   41,   41,  123,
   40,   38,   59,   40,  125,  375,   43,  310,   45,   41,
  313,  314,  315,  316,  290,  291,  292,  293,  294,  295,
   93,  311,   59,   41,  125,   41,  108,  125,  123,   93,
  125,  126,   93,   85,  404,   93,  108,  256,  257,   93,
  259,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,  270,  271,  272,  273,  274,  275,  276,  277,  278,
  279,  280,  281,  282,  283,  284,  285,  286,  287,   56,
   61,  290,  291,   25,  300,  301,  302,  303,  304,  305,
  306,  307,  308,  309,   54,  203,  123,  225,  228,  126,
  226,  310,  227,  390,  313,  314,  315,  316,  195,  229,
  256,  257,  330,  259,  260,   -1,  262,  263,  264,  265,
  266,  267,  268,  269,  270,  271,  272,  273,  274,  275,
  276,  277,  278,  279,  280,  281,  282,  283,  284,  285,
  286,  287,   -1,   -1,  290,  291,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  310,   -1,   -1,  313,  314,  315,
  316,  256,   -1,   -1,   -1,  260,   -1,  262,  263,  264,
  265,  266,  267,   -1,  269,  270,  271,   -1,  273,  274,
   -1,  276,   -1,  278,  279,  280,  281,  282,  283,  284,
   -1,  286,   33,   -1,   -1,  290,  291,   38,   -1,   40,
   -1,   42,   43,   -1,   45,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  310,   -1,   -1,  313,  314,
  315,  316,   -1,  260,   -1,  262,  263,  264,   -1,  266,
   -1,   -1,  269,  270,  271,   -1,  273,  274,   -1,  276,
   -1,  278,  279,   -1,  281,  282,   -1,   -1,   -1,  286,
   91,   -1,   -1,  290,  291,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  310,   -1,   -1,  313,  314,  315,  316,
   -1,   -1,  123,   37,   38,  126,   40,   41,   42,   43,
   44,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   58,   59,   60,   61,   62,   63,
   37,   38,   -1,   -1,   41,   42,   43,   44,   45,   -1,
   47,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   58,   59,   60,   61,   62,   63,   91,   -1,   93,
   94,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   37,   38,   -1,   -1,   41,
   42,   43,   44,   45,   91,   47,   93,   94,   -1,   -1,
  124,  125,  257,  257,  259,  259,   58,   59,   60,   61,
   62,   63,   -1,  268,  268,   -1,   -1,  272,  272,   -1,
  275,  275,  277,  277,   -1,  280,   -1,  124,  125,   -1,
  285,  285,  287,  287,   -1,   -1,   -1,   -1,   -1,   91,
   -1,   93,   94,   -1,   -1,   -1,  257,   -1,  259,   -1,
   -1,   -1,  263,   -1,   -1,   -1,   -1,  268,   -1,  314,
  271,  272,   -1,   -1,  275,   -1,  277,  257,  279,  259,
  281,   -1,  124,  125,  285,  265,  287,  267,  268,  290,
  291,   -1,  272,   -1,   -1,  275,   -1,  277,   -1,   -1,
  280,   -1,   -1,  283,  284,  285,   -1,  287,   -1,  310,
   -1,   -1,  313,  314,  315,  316,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  314,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   37,   38,   -1,   -1,   41,   42,   43,
   44,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   58,   59,   60,   61,   62,   63,
   -1,   -1,   -1,   -1,  288,  289,  290,  291,  292,  293,
  294,  295,  296,  297,  298,  299,  300,  301,  302,  303,
  304,  305,  306,  307,  308,  309,  310,  311,  312,   93,
   94,  288,  289,  290,  291,  292,  293,  294,  295,  296,
  297,  298,  299,  300,  301,  302,  303,  304,  305,  306,
  307,  308,  309,   -1,  311,  312,   -1,   -1,   -1,   -1,
  124,  125,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  288,  289,  290,  291,
  292,  293,  294,  295,  296,  297,  298,  299,  300,  301,
  302,  303,  304,  305,  306,  307,  308,  309,   -1,  311,
  312,   37,   38,   -1,   -1,   41,   42,   43,   44,   45,
   -1,   47,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   58,   59,   60,   61,   62,   63,   38,   -1,
   -1,   41,   -1,   43,   44,   45,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   58,   59,
   60,   61,   62,   63,   -1,   -1,   -1,   93,   94,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,  258,  259,
   -1,   -1,   -1,   -1,   -1,  265,   -1,  267,  268,   -1,
   -1,   -1,  272,   93,   94,  275,   -1,  277,  124,  125,
  280,   -1,   -1,  283,  284,  285,   38,  287,   -1,   41,
   -1,   43,   44,   45,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  124,  125,   58,   59,   60,   61,
   62,   63,   -1,   -1,  314,   -1,  290,  291,  292,  293,
  294,  295,  296,  297,  298,  299,  300,  301,  302,  303,
  304,  305,  306,  307,  308,  309,   -1,  311,  312,   -1,
   38,   93,   94,   41,   -1,   43,   44,   45,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   58,   59,   60,   61,   62,   63,   -1,   -1,   -1,   -1,
   -1,   -1,  124,  125,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   38,   -1,   -1,   41,   -1,   -1,   44,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   93,   94,   -1,   -1,   -1,
   -1,   58,   59,   60,   61,   62,   63,   -1,   -1,   -1,
   -1,   -1,   -1,  257,  257,  259,  259,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  268,  268,  124,  125,  272,  272,
   -1,  275,  275,  277,  277,   -1,   93,   94,   -1,   -1,
   -1,  285,  285,  287,  287,   -1,  292,  293,  294,  295,
  296,  297,  298,  299,  300,  301,  302,  303,  304,  305,
  306,  307,  308,  309,   -1,  311,  312,  124,  125,   -1,
  314,  314,  292,  293,  294,  295,  296,  297,  298,  299,
  300,  301,  302,  303,  304,  305,  306,  307,  308,  309,
   -1,  311,  312,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   38,   -1,   -1,   41,
   -1,   -1,   44,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   58,   59,   60,   61,
   62,   63,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  292,  293,  294,  295,  296,  297,  298,  299,  300,  301,
  302,  303,  304,  305,  306,  307,  308,  309,   -1,  311,
  312,   93,   94,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  124,  125,  292,  293,  294,  295,  296,  297,
  298,  299,  300,  301,  302,  303,  304,  305,  306,  307,
  308,  309,   41,  311,  312,   44,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   58,
   59,   -1,   61,   -1,   -1,  292,  293,  294,  295,  296,
  297,  298,  299,  300,  301,  302,  303,  304,  305,  306,
  307,  308,  309,   38,  311,  312,   41,   -1,   -1,   44,
   -1,   -1,   -1,   -1,   93,   -1,   -1,   -1,   -1,  257,
   -1,  259,   -1,   58,   59,   60,   61,   62,   63,   -1,
  268,   -1,   -1,   -1,  272,   -1,   -1,  275,   -1,  277,
   -1,   -1,  280,   -1,   -1,   38,  125,  285,   41,  287,
   -1,   44,   -1,   -1,   -1,   -1,   -1,   -1,   93,   94,
   -1,   -1,   -1,   -1,   -1,   58,   59,   60,   61,   62,
   63,   -1,   -1,   -1,   -1,   -1,  314,   -1,   -1,   -1,
   -1,   -1,   38,   -1,   -1,   41,   -1,   -1,   44,  124,
  125,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   93,   94,   58,   59,   60,   61,   62,   63,   -1,   -1,
  292,  293,  294,  295,  296,  297,  298,  299,  300,  301,
  302,  303,  304,  305,  306,  307,  308,  309,   -1,  311,
  312,  124,  125,   38,   -1,   -1,   41,   93,   94,   44,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   58,   59,   60,   61,   62,   63,   38,
   -1,   -1,   41,   -1,   -1,   44,   -1,   -1,  124,  125,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   58,
   59,   60,   61,   62,   63,   -1,   -1,   -1,   93,   94,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   93,   94,   -1,   -1,   -1,  124,
  125,  300,  301,  302,  303,  304,  305,  306,  307,  308,
  309,   -1,  311,  312,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  124,  125,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  292,  293,  294,
  295,  296,  297,  298,  299,  300,  301,  302,  303,  304,
  305,  306,  307,  308,  309,   38,  311,  312,   41,   -1,
   -1,   44,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   58,   59,   60,   61,   62,
   63,  294,  295,  296,  297,  298,  299,  300,  301,  302,
  303,  304,  305,  306,  307,  308,  309,   -1,  311,  312,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   93,   94,   -1,   -1,   -1,   -1,   -1,   -1,  294,  295,
  296,  297,  298,  299,  300,  301,  302,  303,  304,  305,
  306,  307,  308,  309,   38,  311,  312,   41,   -1,   -1,
   44,  124,  125,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   58,   59,   -1,   61,   -1,   63,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  294,
  295,  296,  297,  298,  299,  300,  301,  302,  303,  304,
  305,  306,  307,  308,  309,   -1,  311,  312,   -1,   93,
   94,   -1,   -1,   -1,   -1,  294,  295,  296,  297,  298,
  299,  300,  301,  302,  303,  304,  305,  306,  307,  308,
  309,   38,  311,  312,   41,   -1,   -1,   44,   -1,   -1,
  124,  125,  257,   -1,  259,   -1,   -1,   -1,   -1,   -1,
   -1,   58,   59,  268,   61,   -1,   63,  272,   -1,   -1,
  275,   -1,  277,   -1,   -1,   -1,   -1,   -1,   38,   -1,
  285,   41,  287,   -1,   44,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   93,   94,   58,   59,
   -1,   61,   -1,   63,   -1,   -1,   -1,   -1,   -1,  314,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  124,  125,   -1,
   -1,   -1,   -1,   93,   94,   -1,   -1,   -1,   -1,   -1,
   -1,  294,  295,  296,  297,  298,  299,  300,  301,  302,
  303,  304,  305,  306,  307,  308,  309,  112,  311,  312,
   -1,   -1,   -1,   -1,  124,  125,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   38,   -1,   -1,   41,
   -1,   -1,   44,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   58,   59,   -1,   61,
   -1,   63,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  296,  297,  298,  299,  300,  301,  302,  303,
  304,  305,  306,  307,  308,  309,   -1,  311,  312,  194,
  195,   93,   94,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  206,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  124,  125,   -1,   -1,  231,  232,  233,  234,
  235,  236,  237,  238,  239,  240,  241,   -1,  243,   -1,
  245,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  296,
  297,  298,  299,  300,  301,  302,  303,  304,  305,  306,
  307,  308,  309,   41,  311,  312,   44,  272,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   58,   59,   -1,   61,   -1,   63,  296,  297,  298,  299,
  300,  301,  302,  303,  304,  305,  306,  307,  308,  309,
   -1,  311,  312,   -1,   -1,   -1,   -1,   -1,   38,   -1,
   -1,   41,   -1,   -1,   44,   93,   94,   -1,  323,   -1,
   -1,   -1,   -1,   -1,  329,  330,   -1,  332,   58,   59,
   -1,   61,   -1,   63,   41,  340,   -1,   44,   -1,  344,
   -1,   -1,   -1,   -1,   -1,   -1,  124,  125,   -1,   -1,
   -1,   58,   59,   -1,   61,   -1,   63,  362,   -1,   -1,
   -1,   -1,   -1,   93,   94,   37,   38,   -1,   40,   -1,
   42,   43,   44,   45,   -1,   47,  381,   -1,   -1,   -1,
   -1,  386,   -1,   -1,   -1,   -1,   93,   59,   60,   61,
   62,   63,   -1,   -1,  124,  125,  298,  299,  300,  301,
  302,  303,  304,  305,  306,  307,  308,  309,   41,  311,
  312,   44,   -1,   -1,   -1,   -1,   -1,  124,  125,   91,
   -1,   -1,   94,   -1,   41,   58,   59,   44,   61,   -1,
   63,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   58,   59,   -1,   61,   -1,   63,   -1,   41,   -1,
   -1,   44,  124,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   93,   94,   -1,   -1,   41,   58,   59,   44,   61,   -1,
   63,   -1,   -1,   -1,   -1,   -1,   93,   -1,   -1,   -1,
   -1,   58,   59,   -1,   61,   -1,   63,   -1,   -1,   -1,
   -1,  124,  125,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   93,   -1,   -1,   -1,   -1,   -1,   -1,  124,  125,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   93,   -1,   -1,   -1,
  298,  299,  300,  301,  302,  303,  304,  305,  306,  307,
  308,  309,  125,  311,  312,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  125,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  298,  299,
  300,  301,  302,  303,  304,  305,  306,  307,  308,  309,
   -1,  311,  312,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  298,  299,  300,  301,  302,  303,  304,  305,  306,
  307,  308,  309,   -1,  311,  312,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  288,  289,  290,  291,
  292,  293,  294,  295,  296,  297,  298,  299,  300,  301,
  302,  303,  304,  305,  306,  307,  308,  309,  310,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  298,  299,  300,  301,  302,
  303,  304,  305,  306,  307,  308,  309,   -1,  311,  312,
   -1,  298,  299,  300,  301,  302,  303,  304,  305,  306,
  307,  308,  309,   -1,  311,  312,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  298,  299,  300,  301,  302,
  303,  304,  305,  306,  307,  308,  309,   -1,  311,  312,
   -1,  298,  299,  300,  301,  302,  303,  304,  305,  306,
  307,  308,  309,   41,  311,  312,   44,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  117,   -1,   -1,   41,
   58,   59,   44,   61,   -1,   63,   -1,   -1,   -1,   -1,
   -1,   -1,  133,   -1,   -1,   -1,   58,   59,   -1,   61,
   -1,   63,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   93,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   93,  173,   -1,  175,   -1,   -1,   -1,   -1,  180,
   -1,  182,   -1,   -1,   -1,  186,   -1,  125,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  125,   -1,   -1,   -1,   -1,  209,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  257,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  301,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  317,  318,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  346,   -1,   -1,   -1,   -1,
   -1,   -1,  353,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  299,  300,  301,  302,  303,  304,  305,  306,  307,
  308,  309,   -1,  311,  312,  376,   -1,  299,  300,  301,
  302,  303,  304,  305,  306,  307,  308,  309,   -1,  311,
  312,
};
#define YYFINAL 1
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 321
#if YYDEBUG
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
"'!'",0,0,0,"'%'","'&'",0,"'('","')'","'*'","'+'","','","'-'",0,"'/'",0,0,0,0,0,
0,0,0,0,0,"':'","';'","'<'","'='","'>'","'?'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,"'['",0,"']'","'^'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,"'{'","'|'","'}'","'~'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"VOID","INHERIT",
"MAPPING","BREAK","ELSE","CASE","NIL","FOR","STATIC","CONTINUE","PRIVATE",
"FUNCTION","RLIMITS","RETURN","OPERATOR","FLOAT","DO","IF","OBJECT","GOTO",
"STRING","WHILE","NEW","VARARGS","CATCH","SWITCH","NOMASK","ATOMIC","INT",
"DEFAULT","MIXED","LARROW","RARROW","PLUS_PLUS","MIN_MIN","LSHIFT","RSHIFT",
"LE","GE","EQ","NE","LAND","LOR","PLUS_EQ","MIN_EQ","MULT_EQ","DIV_EQ","MOD_EQ",
"LSHIFT_EQ","RSHIFT_EQ","AND_EQ","XOR_EQ","OR_EQ","COLON_COLON","DOT_DOT",
"ELLIPSIS","STRING_CONST","IDENTIFIER","INT_CONST","FLOAT_CONST","MARK","HASH",
"HASH_HASH","INCL_CONST","NR_TOKENS",
};
char *yyrule[] = {
"$accept : program",
"$$1 :",
"program : $$1 top_level_declarations",
"top_level_declarations :",
"top_level_declarations : top_level_declarations top_level_declaration",
"top_level_declaration : opt_private INHERIT opt_inherit_label opt_object composite_string ';'",
"top_level_declaration : data_declaration",
"top_level_declaration : function_declaration",
"opt_inherit_label :",
"opt_inherit_label : ident",
"ident : IDENTIFIER",
"composite_string : string",
"composite_string : composite_string '+' string",
"composite_string : '(' composite_string ')'",
"string : STRING_CONST",
"data_declaration : class_specifier_list type_specifier list_dcltr ';'",
"$$2 :",
"function_declaration : class_specifier_list type_specifier function_dcltr $$2 compound_stmt",
"$$3 :",
"function_declaration : class_specifier_list ident '(' formals_declaration ')' $$3 compound_stmt",
"local_data_declaration : class_specifier_list type_specifier list_dcltr ';'",
"formals_declaration :",
"formals_declaration : VOID",
"formals_declaration : formal_declaration_list",
"formals_declaration : formal_declaration_list ELLIPSIS",
"formal_declaration_list : varargs_formal_declaration",
"formal_declaration_list : formal_declaration_list ',' varargs_formal_declaration",
"varargs_formal_declaration : VARARGS formal_declaration",
"varargs_formal_declaration : formal_declaration",
"formal_declaration : type_specifier data_dcltr",
"formal_declaration : ident",
"class_specifier_list : opt_private",
"class_specifier_list : non_private",
"class_specifier_list : class_specifier class_specifier_list2",
"class_specifier_list2 : class_specifier",
"class_specifier_list2 : class_specifier_list2 class_specifier",
"class_specifier : PRIVATE",
"class_specifier : non_private",
"opt_private :",
"opt_private : PRIVATE",
"non_private : STATIC",
"non_private : ATOMIC",
"non_private : NOMASK",
"non_private : VARARGS",
"type_specifier : INT",
"type_specifier : FLOAT",
"type_specifier : STRING",
"type_specifier : OBJECT",
"type_specifier : OBJECT composite_string",
"type_specifier : MAPPING",
"type_specifier : FUNCTION",
"type_specifier : MIXED",
"type_specifier : VOID",
"opt_object :",
"opt_object : OBJECT",
"star_list :",
"star_list : star_list '*'",
"data_dcltr : star_list ident",
"operator : OPERATOR '+'",
"operator : OPERATOR '-'",
"operator : OPERATOR '*'",
"operator : OPERATOR '/'",
"operator : OPERATOR '%'",
"operator : OPERATOR '&'",
"operator : OPERATOR '^'",
"operator : OPERATOR '|'",
"operator : OPERATOR '<'",
"operator : OPERATOR '>'",
"operator : OPERATOR LE",
"operator : OPERATOR GE",
"operator : OPERATOR LSHIFT",
"operator : OPERATOR RSHIFT",
"operator : OPERATOR '~'",
"operator : OPERATOR PLUS_PLUS",
"operator : OPERATOR MIN_MIN",
"operator : OPERATOR '[' ']'",
"operator : OPERATOR '[' ']' '='",
"operator : OPERATOR '[' DOT_DOT ']'",
"function_name : ident",
"function_name : operator",
"function_dcltr : star_list function_name '(' formals_declaration ')'",
"dcltr : data_dcltr",
"dcltr : function_dcltr",
"list_dcltr : dcltr",
"list_dcltr : list_dcltr ',' dcltr",
"dcltr_or_stmt_list :",
"dcltr_or_stmt_list : dcltr_or_stmt_list dcltr_or_stmt",
"dcltr_or_stmt : local_data_declaration",
"dcltr_or_stmt : stmt",
"dcltr_or_stmt : error ';'",
"$$4 :",
"if_stmt : IF '(' f_list_exp ')' $$4 stmt",
"stmt : list_exp ';'",
"stmt : compound_stmt",
"stmt : if_stmt",
"$$5 :",
"stmt : if_stmt ELSE $$5 stmt",
"$$6 :",
"stmt : DO $$6 stmt WHILE '(' f_list_exp ')' ';'",
"$$7 :",
"stmt : WHILE '(' f_list_exp ')' $$7 stmt",
"$$8 :",
"stmt : FOR '(' opt_list_exp ';' f_opt_list_exp ';' opt_list_exp ')' $$8 stmt",
"$$9 :",
"stmt : RLIMITS '(' f_list_exp ';' f_list_exp ')' $$9 compound_stmt",
"$$10 :",
"$$11 :",
"stmt : CATCH $$10 compound_stmt $$11 opt_caught_stmt",
"$$12 :",
"stmt : SWITCH '(' f_list_exp ')' $$12 compound_stmt",
"$$13 :",
"stmt : CASE exp ':' $$13 stmt",
"$$14 :",
"stmt : CASE exp DOT_DOT exp ':' $$14 stmt",
"$$15 :",
"stmt : DEFAULT ':' $$15 stmt",
"$$16 :",
"stmt : ident ':' $$16 stmt",
"stmt : GOTO ident ';'",
"stmt : BREAK ';'",
"stmt : CONTINUE ';'",
"stmt : RETURN f_opt_list_exp ';'",
"stmt : ';'",
"$$17 :",
"compound_stmt : '{' $$17 dcltr_or_stmt_list '}'",
"opt_caught_stmt :",
"opt_caught_stmt : ':' stmt",
"function_call : function_name",
"function_call : COLON_COLON function_name",
"function_call : function_name COLON_COLON function_name",
"primary_p1_exp : INT_CONST",
"primary_p1_exp : FLOAT_CONST",
"primary_p1_exp : NIL",
"primary_p1_exp : string",
"primary_p1_exp : '(' '{' opt_arg_list_comma '}' ')'",
"primary_p1_exp : '(' '[' opt_assoc_arg_list_comma ']' ')'",
"primary_p1_exp : ident",
"primary_p1_exp : '(' list_exp ')'",
"primary_p1_exp : function_call '(' opt_arg_list ')'",
"primary_p1_exp : '&' ident '(' opt_arg_list ')'",
"primary_p1_exp : '&' '(' '*' cast_exp ')' '(' opt_arg_list ')'",
"primary_p1_exp : '(' '*' cast_exp ')' '(' opt_arg_list ')'",
"$$18 :",
"primary_p1_exp : CATCH '(' $$18 list_exp ')'",
"primary_p1_exp : NEW opt_object string",
"primary_p1_exp : NEW opt_object '(' composite_string ')'",
"primary_p1_exp : NEW opt_object string '(' opt_arg_list ')'",
"primary_p1_exp : NEW opt_object '(' composite_string ')' '(' opt_arg_list ')'",
"primary_p1_exp : primary_p2_exp RARROW ident '(' opt_arg_list ')'",
"primary_p1_exp : primary_p2_exp LARROW opt_object string",
"primary_p1_exp : primary_p2_exp LARROW opt_object '(' composite_string ')'",
"primary_p2_exp : primary_p1_exp",
"primary_p2_exp : primary_p2_exp '[' f_list_exp ']'",
"primary_p2_exp : primary_p2_exp '[' f_opt_list_exp DOT_DOT f_opt_list_exp ']'",
"postfix_exp : primary_p2_exp",
"postfix_exp : postfix_exp PLUS_PLUS",
"postfix_exp : postfix_exp MIN_MIN",
"prefix_exp : postfix_exp",
"prefix_exp : PLUS_PLUS cast_exp",
"prefix_exp : MIN_MIN cast_exp",
"prefix_exp : '-' cast_exp",
"prefix_exp : '+' cast_exp",
"prefix_exp : '!' cast_exp",
"prefix_exp : '~' cast_exp",
"cast_exp : prefix_exp",
"cast_exp : '(' type_specifier star_list ')' cast_exp",
"mult_oper_exp : cast_exp",
"mult_oper_exp : mult_oper_exp '*' cast_exp",
"mult_oper_exp : mult_oper_exp '/' cast_exp",
"mult_oper_exp : mult_oper_exp '%' cast_exp",
"add_oper_exp : mult_oper_exp",
"add_oper_exp : add_oper_exp '+' mult_oper_exp",
"add_oper_exp : add_oper_exp '-' mult_oper_exp",
"shift_oper_exp : add_oper_exp",
"shift_oper_exp : shift_oper_exp LSHIFT add_oper_exp",
"shift_oper_exp : shift_oper_exp RSHIFT add_oper_exp",
"rel_oper_exp : shift_oper_exp",
"rel_oper_exp : rel_oper_exp '<' shift_oper_exp",
"rel_oper_exp : rel_oper_exp '>' shift_oper_exp",
"rel_oper_exp : rel_oper_exp LE shift_oper_exp",
"rel_oper_exp : rel_oper_exp GE shift_oper_exp",
"equ_oper_exp : rel_oper_exp",
"equ_oper_exp : equ_oper_exp EQ rel_oper_exp",
"equ_oper_exp : equ_oper_exp NE rel_oper_exp",
"bitand_oper_exp : equ_oper_exp",
"bitand_oper_exp : bitand_oper_exp '&' equ_oper_exp",
"bitxor_oper_exp : bitand_oper_exp",
"bitxor_oper_exp : bitxor_oper_exp '^' bitand_oper_exp",
"bitor_oper_exp : bitxor_oper_exp",
"bitor_oper_exp : bitor_oper_exp '|' bitxor_oper_exp",
"and_oper_exp : bitor_oper_exp",
"and_oper_exp : and_oper_exp LAND bitor_oper_exp",
"or_oper_exp : and_oper_exp",
"or_oper_exp : or_oper_exp LOR and_oper_exp",
"cond_exp : or_oper_exp",
"$$19 :",
"$$20 :",
"cond_exp : or_oper_exp '?' $$19 list_exp ':' $$20 cond_exp",
"exp : cond_exp",
"exp : cond_exp '=' exp",
"exp : cond_exp PLUS_EQ exp",
"exp : cond_exp MIN_EQ exp",
"exp : cond_exp MULT_EQ exp",
"exp : cond_exp DIV_EQ exp",
"exp : cond_exp MOD_EQ exp",
"exp : cond_exp LSHIFT_EQ exp",
"exp : cond_exp RSHIFT_EQ exp",
"exp : cond_exp AND_EQ exp",
"exp : cond_exp XOR_EQ exp",
"exp : cond_exp OR_EQ exp",
"list_exp : exp",
"list_exp : list_exp ',' exp",
"opt_list_exp :",
"opt_list_exp : list_exp",
"f_list_exp : list_exp",
"f_opt_list_exp : opt_list_exp",
"arg_list : exp",
"arg_list : arg_list ',' exp",
"opt_arg_list :",
"opt_arg_list : arg_list",
"opt_arg_list : arg_list ELLIPSIS",
"opt_arg_list_comma :",
"opt_arg_list_comma : arg_list",
"opt_arg_list_comma : arg_list ','",
"assoc_exp : exp ':' exp",
"assoc_arg_list : assoc_exp",
"assoc_arg_list : assoc_arg_list ',' assoc_exp",
"opt_assoc_arg_list_comma :",
"opt_assoc_arg_list_comma : assoc_arg_list",
"opt_assoc_arg_list_comma : assoc_arg_list ','",
};
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH 10000
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short yyss[YYSTACKSIZE];
#define yysslim (&yyss[YYSTACKSIZE - 1])
YYSTYPE yyvs[YYSTACKSIZE];
#define yystacksize YYSTACKSIZE
#line 932 "parser.y"

/*
 * NAME:	t_void()
 * DESCRIPTION:	if the argument is of type void, an error will result
 */
static void t_void(node *n)
{
    if (n != (node *) NULL && n->mod == T_VOID) {
	c_error("void value not ignored");
	n->mod = T_MIXED;
    }
}

/*
 * NAME:	t_unary()
 * DESCRIPTION:	typecheck the argument of a unary operator
 */
static bool t_unary(node *n, char *name)
{
    char tnbuf[TNBUFSIZE];

    t_void(n);
    if (typechecking && !T_ARITHMETIC(n->mod) && n->mod != T_MIXED) {
	c_error("bad argument type for %s (%s)", name,
		i_typename(tnbuf, n->mod));
	n->mod = T_MIXED;
	return FALSE;
    }
    return TRUE;
}

/*
 * NAME:	postfix()
 * DESCRIPTION:	handle a postfix assignment operator
 */
static node *postfix(int op, node *n, char *name)
{
    t_unary(n, name);
    return node_mon((n->mod == T_INT) ? op + 1 : op, n->mod, c_lvalue(n, name));
}

/*
 * NAME:	prefix()
 * DESCRIPTION:	handle a prefix assignment operator
 */
static node *prefix(int op, node *n, char *name)
{
    unsigned short type;

    if (n->mod == T_OBJECT || n->mod == T_CLASS) {
	type = T_OBJECT;
    } else {
	t_unary(n, name);
	type = n->mod;
    }
    return node_mon(op, type, c_lvalue(n, name));
}

/*
 * NAME:	cast()
 * DESCRIPTION:	cast an expression to a type
 */
static node *cast(node *n, node *type)
{
    xfloat flt;
    Int i;
    char *p, buffer[18];

    if (type->mod != n->mod) {
	switch (type->mod) {
	case T_INT:
	    switch (n->type) {
	    case N_FLOAT:
		/* cast float constant to int */
		NFLT_GET(n, flt);
		return node_int(flt_ftoi(&flt));

	    case N_STR:
		/* cast string to int */
		p = n->l.string->text;
		i = strtoint(&p);
		if (p == n->l.string->text + n->l.string->len) {
		    return node_int(i);
		} else {
		    c_error("cast of invalid string constant");
		    n->mod = T_MIXED;
		}
		break;

	    case N_TOFLOAT:
	    case N_TOSTRING:
		if (n->l.left->type == N_INT) {
		    /* (int) (float) i, (int) (string) i */
		    return n->l.left;
		}
		/* fall through */
	    default:
		if (n->mod == T_FLOAT || n->mod == T_STRING ||
		    n->mod == T_MIXED) {
		    return node_mon(N_TOINT, T_INT, n);
		}
		break;
	    }
	    break;

	case T_FLOAT:
	    switch (n->type) {
	    case N_INT:
		/* cast int constant to float */
		flt_itof(n->l.number, &flt);
		return node_float(&flt);

	    case N_STR:
		/* cast string to float */
		p = n->l.string->text;
		if (flt_atof(&p, &flt) &&
		    p == n->l.string->text + n->l.string->len) {
		    return node_float(&flt);
		} else {
		    yyerror("cast of invalid string constant");
		    n->mod = T_MIXED;
		}
		break;

	    case N_TOSTRING:
		if (n->l.left->mod == T_INT) {
		    return node_mon(N_TOFLOAT, T_FLOAT, n->l.left);
		}
		/* fall through */
	    default:
		if (n->mod == T_INT || n->mod == T_STRING || n->mod == T_MIXED)
		{
		    return node_mon(N_TOFLOAT, T_FLOAT, n);
		}
		break;
	    }
	    break;

	case T_STRING:
	    switch (n->type) {
	    case N_INT:
		/* cast int constant to string */
		sprintf(buffer, "%ld", (long) n->l.number);
		return node_str(str_new(buffer, (long) strlen(buffer)));

	    case N_FLOAT:
		/* cast float constant to string */
		NFLT_GET(n, flt);
		flt_ftoa(&flt, buffer);
		return node_str(str_new(buffer, (long) strlen(buffer)));

	    default:
		if (n->mod == T_INT || n->mod == T_FLOAT || n->mod == T_MIXED) {
		    return node_mon(N_TOSTRING, T_STRING, n);
		}
		break;
	    }
	    break;
	}

	if (type->mod == T_MIXED || (type->mod & T_TYPE) == T_VOID) {
	    /* (mixed), (void), (void *) */
	    c_error("cannot cast to %s", i_typename(buffer, type->mod));
	    n->mod = T_MIXED;
	} else if ((type->mod & T_REF) < (n->mod & T_REF)) {
	    /* (mixed *) of (mixed **) */
	    c_error("illegal cast of array type (%s)",
		    i_typename(buffer, n->mod));
	} else if ((n->mod & T_TYPE) != T_MIXED &&
		   ((type->mod & T_TYPE) != T_CLASS ||
		    ((n->mod & T_TYPE) != T_OBJECT &&
		     (n->mod & T_TYPE) != T_CLASS) ||
		    (type->mod & T_REF) != (n->mod & T_REF))) {
	    /* can only cast from mixed, or object/class to class */
	    c_error("cast of invalid type (%s)", i_typename(buffer, n->mod));
	} else {
	    if ((type->mod & T_REF) == 0 || (n->mod & T_REF) == 0) {
		/* runtime cast */
		n = node_mon(N_CAST, type->mod, n);
	    } else {
		n->mod = type->mod;
	    }
	    n->class = type->class;
	}
    } else if (type->mod == T_CLASS && str_cmp(type->class, n->class) != 0) {
	/*
	 * cast to different object class
	 */
	n = node_mon(N_CAST, type->mod, n);
	n->class = type->class;
    }
    return n;
}

/*
 * NAME:	idx()
 * DESCRIPTION:	handle the [ ] operator
 */
static node *idx(node *n1, node *n2)
{
    char tnbuf[TNBUFSIZE];
    unsigned short type;

    if (n1->type == N_STR && n2->type == N_INT) {
	/* str [ int ] */
	if (n2->l.number < 0 || n2->l.number >= (Int) n1->l.string->len) {
	    c_error("string index out of range");
	} else {
	    n2->l.number =
		    UCHAR(n1->l.string->text[str_index(n1->l.string,
						       (long) n2->l.number)]);
	}
	return n2;
    }

    if ((n1->mod & T_REF) != 0) {
	/*
	 * array
	 */
	if (typechecking) {
	    type = n1->mod - (1 << REFSHIFT);
	    if (n2->mod != T_INT && n2->mod != T_MIXED) {
		c_error("bad index type (%s)", i_typename(tnbuf, n2->mod));
	    }
	    if (type != T_MIXED) {
		/* you can't trust these arrays */
		n2 = node_mon(N_CAST, type, node_bin(N_INDEX, type, n1, n2));
		n2->class = n1->class;
		return n2;
	    }
	}
	type = T_MIXED;
    } else if (n1->mod == T_STRING) {
	/*
	 * string
	 */
	if (typechecking && n2->mod != T_INT && n2->mod != T_MIXED) {
	    c_error("bad index type (%s)", i_typename(tnbuf, n2->mod));
	}
	type = T_INT;
    } else {
	if (typechecking && n1->mod != T_OBJECT && n1->mod != T_CLASS &&
	    n1->mod != T_MAPPING && n1->mod != T_MIXED) {
	    c_error("bad indexed type (%s)", i_typename(tnbuf, n1->mod));
	}
	type = T_MIXED;
    }
    return node_bin(N_INDEX, type, n1, n2);
}

/*
 * NAME:	range()
 * DESCRIPTION:	handle the [ .. ] operator
 */
static node *range(node *n1, node *n2, node *n3)
{
    unsigned short type;

    if (n1->type == N_STR && (n2 == (node *) NULL || n2->type == N_INT) &&
	(n3 == (node *) NULL || n3->type == N_INT)) {
	Int from, to;

	/* str [ int .. int ] */
	from = (n2 == (node *) NULL) ? 0 : n2->l.number;
	to = (n3 == (node *) NULL) ? n1->l.string->len - 1 : n3->l.number;
	if (from < 0 || from > to + 1 || to >= n1->l.string->len) {
	    c_error("invalid string range");
	} else {
	    return node_str(str_range(n1->l.string, (long) from, (long) to));
	}
    }

    type = T_MIXED;
    if (n1->mod == T_OBJECT || n1->mod == T_CLASS) {
	type = T_OBJECT;
    } else if (n1->mod == T_MAPPING) {
	type = T_MAPPING;
    } else if (typechecking && n1->mod != T_MIXED) {
	char tnbuf[TNBUFSIZE];

	/* indices */
	if (n2 != (node *) NULL && n2->mod != T_INT && n2->mod != T_MIXED) {
	    c_error("bad index type (%s)", i_typename(tnbuf, n2->mod));
	}
	if (n3 != (node *) NULL && n3->mod != T_INT && n3->mod != T_MIXED) {
	    c_error("bad index type (%s)", i_typename(tnbuf, n3->mod));
	}
	/* range */
	if ((n1->mod & T_REF) == 0 && n1->mod != T_STRING && n1->mod != T_MIXED)
	{
	    c_error("bad indexed type (%s)", i_typename(tnbuf, n1->mod));
	}
	type = n1->mod;
    }

    return node_bin(N_RANGE, type, n1, node_bin(N_PAIR, 0, n2, n3));
}

/*
 * NAME:	bini()
 * DESCRIPTION:	handle a binary int operator
 */
static node *bini(int op, node *n1, node *n2, char *name)
{
    char tnbuf1[TNBUFSIZE], tnbuf2[TNBUFSIZE];
    unsigned short type;

    t_void(n1);
    t_void(n2);

    type = T_MIXED;
    if (n1->mod == T_OBJECT || n1->mod == T_CLASS) {
	type = T_OBJECT;
    } else if (n1->mod == T_INT && (n2->mod == T_INT || n2->mod == T_MIXED)) {
	type = T_INT;
    } else if (typechecking && n1->mod != T_MIXED) {
	c_error("bad argument types for %s (%s, %s)", name,
		i_typename(tnbuf1, n1->mod), i_typename(tnbuf2, n2->mod));
    }
    if (n1->mod == T_INT && n2->mod == T_INT) {
	op++;
    }
    return node_bin(op, type, n1, n2);
}


/*
 * NAME:	bina()
 * DESCRIPTION:	handle a binary arithmetic operator
 */
static node *bina(int op, node *n1, node *n2, char *name)
{
    char tnbuf1[TNBUFSIZE], tnbuf2[TNBUFSIZE];
    unsigned short type;

    t_void(n1);
    t_void(n2);

    type = T_MIXED;
    if (n1->mod == T_OBJECT || n1->mod == T_CLASS) {
	type = T_OBJECT;
    } else if (n1->mod == T_INT && (n2->mod == T_INT || n2->mod == T_MIXED)) {
	if (n1->mod == T_INT && n2->mod == T_INT) {
	    op++;
	}
	type = T_INT;
    } else if (n1->mod == T_FLOAT && (n2->mod == T_FLOAT || n2->mod == T_MIXED))
    {
	type = T_FLOAT;
	switch(op) {
	    case N_ADD:
	    case N_ADD_EQ:
	    case N_ADD_EQ_1:
	    case N_DIV:
	    case N_DIV_EQ:
	    case N_EQ:
	    case N_GE:
	    case N_GT:
	    case N_LE:
	    case N_LT:
	    case N_MULT:
	    case N_MULT_EQ:
	    case N_NE:
	    case N_SUB_EQ_1:
	    case N_SUB_EQ:
	    case N_MIN_MIN:
	    case N_PLUS_PLUS:
		op+=2;
		break;
	    default:
		break;
	}
    } else if (typechecking && n1->mod != T_MIXED) {
	c_error("bad argument types for %s (%s, %s)", name,
		i_typename(tnbuf1, n1->mod), i_typename(tnbuf2, n2->mod));
    }

    return node_bin(op, type, n1, n2);
}

/*
 * NAME:	mult()
 * DESCRIPTION:	handle the * *= operators
 */
static node *mult(int op, node *n1, node *n2, char *name)
{
    xfloat f1, f2;

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i * i */
	n1->l.number *= n2->l.number;
	return n1;
    }
    if (n1->type == N_FLOAT && n2->type == N_FLOAT) {
	NFLT_GET(n1, f1);
	NFLT_GET(n2, f2);
	flt_mult(&f1, &f2);
	NFLT_PUT(n1, f1);
	return n1;
    }
    return bina(op, n1, n2, name);
}

/*
 * NAME:	mdiv()
 * DESCRIPTION:	handle the / /= operators
 */
static node *mdiv(int op, node *n1, node *n2, char *name)
{
    xfloat f1, f2;

    if (n1->type == N_INT && n2->type == N_INT) {
	Int i, d;

	/* i / i */
	i = n1->l.number;
	d = n2->l.number;
	if (d == 0) {
	    /* i / 0 */
	    c_error("division by zero");
	    return n1;
	}
	n1->l.number = i / d;
	return n1;
    } else if (n1->type == N_FLOAT && n2->type == N_FLOAT) {
	/* f / f */
	if (NFLT_ISZERO(n2)) {
	    /* f / 0.0 */
	    c_error("division by zero");
	    return n1;
	}
	NFLT_GET(n1, f1);
	NFLT_GET(n2, f2);
	flt_div(&f1, &f2);
	NFLT_PUT(n1, f1);
	return n1;
    }

    return bina(op, n1, n2, name);
}

/*
 * NAME:	mod()
 * DESCRIPTION:	handle the % %= operators
 */
static node *mod(int op, node *n1, node *n2, char *name)
{
    if (n1->type == N_INT && n2->type == N_INT) {
	Int i, d;

	/* i % i */
	i = n1->l.number;
	d = n2->l.number;
	if (d == 0) {
	    /* i % 0 */
	    c_error("modulus by zero");
	    return n1;
	}
	n1->l.number = i % d;
	return n1;
    }

    return bini(op, n1, n2, name);
}

/*
 * NAME:	add()
 * DESCRIPTION:	handle the + += operators, possibly rearranging the order
 *		of the expression
 */
static node *add(int op, node *n1, node *n2, char *name)
{
    char tnbuf1[TNBUFSIZE], tnbuf2[TNBUFSIZE];
    xfloat f1, f2;
    unsigned short type;

    t_void(n1);
    t_void(n2);

    if (n1->mod == T_STRING) {
	if (n2->mod == T_INT || n2->mod == T_FLOAT ||
	    (n2->mod == T_MIXED && typechecking)) {
	    n2 = cast(n2, node_type(T_STRING, (string *) NULL));
	}
    } else if (n2->mod == T_STRING && op == N_ADD) {
	if (n1->mod == T_INT || n1->mod == T_FLOAT) {
	    n1 = cast(n1, node_type(T_STRING, (string *) NULL));
	}
    }

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i + i */
	n1->l.number += n2->l.number;
	return n1;
    }
    if (n1->type == N_FLOAT && n2->type == N_FLOAT) {
	/* f + f */
	NFLT_GET(n1, f1);
	NFLT_GET(n2, f2);
	flt_add(&f1, &f2);
	NFLT_PUT(n1, f1);
	return n1;
    }
    if (n1->type == N_STR && n2->type == N_STR) {
	/* s + s */
	return node_str(str_add(n1->l.string, n2->l.string));
    }

    if (n1->mod == T_OBJECT || n1->mod == T_CLASS) {
	type = T_OBJECT;
    } else if ((type=c_tmatch(n1->mod, n2->mod)) == T_NIL) {
	type = T_MIXED;
	if (typechecking) {
	    c_error("bad argument types for %s (%s, %s)", name,
		    i_typename(tnbuf1, n1->mod), i_typename(tnbuf2, n2->mod));
	}
    } else if (type == T_INT) {
	op++;
    } else if (op == N_ADD_EQ && n1->mod != n2->mod) {
	type = n1->mod;
	if (n1->mod == T_INT) {
	    n2 = node_mon(N_CAST, T_INT, n2);
	    type = T_INT;
	    op++;
	} else if (n1->mod == T_FLOAT) {
	    n2 = node_mon(N_CAST, T_FLOAT, n2);
	    type = T_FLOAT;
	}
    }
    return node_bin(op, type, n1, n2);
}

/*
 * NAME:	sub()
 * DESCRIPTION:	handle the - -= operators
 */
static node *sub(int op, node *n1, node *n2, char *name)
{
    char tnbuf1[TNBUFSIZE], tnbuf2[TNBUFSIZE];
    xfloat f1, f2;
    unsigned short type;

    t_void(n1);
    t_void(n2);

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i - i */
	n1->l.number -= n2->l.number;
	return n1;
    }
    if (n1->type == N_FLOAT && n2->type == N_FLOAT) {
	/* f - f */
	NFLT_GET(n1, f1);
	NFLT_GET(n2, f2);
	flt_sub(&f1, &f2);
	NFLT_PUT(n1, f1);
	return n1;
    }

    if (n1->mod == T_OBJECT || n1->mod == T_CLASS) {
	type = T_OBJECT;
    } else if ((type=c_tmatch(n1->mod, n2->mod)) == T_NIL || type == T_STRING ||
	       type == T_MAPPING) {
	if ((type=n1->mod) != T_MAPPING ||
	    (n2->mod != T_MIXED && (n2->mod & T_REF) == 0)) {
	    type = T_MIXED;
	    if (typechecking) {
		c_error("bad argument types for %s (%s, %s)", name,
			i_typename(tnbuf1, n1->mod),
			i_typename(tnbuf2, n2->mod));
	    }
	}
    } else if (type == T_INT) {
	op++;
    } else if (type == T_MIXED) {
	type = n1->mod;
    } else if (n1->mod == T_MIXED && (n2->mod & T_REF)) {
	type = T_MIXED;
    }
    return node_bin(op, type, n1, n2);
}

/*
 * NAME:	umin()
 * DESCRIPTION:	handle unary minus
 */
static node *umin(node *n)
{
    xfloat flt;

    if (n->mod == T_OBJECT || n->mod == T_CLASS) {
	return node_mon(N_UMIN, T_OBJECT, n);
    } else if (n->mod == T_MIXED) {
	return node_mon(N_UMIN, T_MIXED, n);
    } else if (t_unary(n, "unary -")) {
	if (n->mod == T_FLOAT) {
	    FLT_ZERO(flt.high, flt.low);
	    n = sub(N_SUB, node_float(&flt), n, "-");
	} else {
	    n = sub(N_SUB, node_int((Int) 0), n, "-");
	}
    }
    return n;
}

/*
 * NAME:	lshift()
 * DESCRIPTION:	handle the << <<= operators
 */
static node *lshift(int op, node *n1, node *n2, char *name)
{
    if (n2->type == N_INT) {
	if (n2->l.number < 0) {
	    c_error("negative left shift");
	    n2->l.number = 0;
	}
	if (n1->type == N_INT) {
	    /* i << i */
	    n1->l.number = (n2->l.number < 32) ?
			    (Uint) n1->l.number << n2->l.number : 0;
	    return n1;
	}
    }

    return bini(op, n1, n2, name);
}

/*
 * NAME:	rshift()
 * DESCRIPTION:	handle the >> >>= operators
 */
static node *rshift(int op, node *n1, node *n2, char *name)
{
    if (n2->type == N_INT) {
	if (n2->l.number < 0) {
	    c_error("negative right shift");
	    n2->l.number = 0;
	}
	if (n1->type == N_INT) {
	    /* i >> i */
	    n1->l.number = (n2->l.number < 32) ?
			    (Uint) n1->l.number >> n2->l.number : 0;
	    return n1;
	}
    }

    return bini(op, n1, n2, name);
}

/*
 * NAME:	rel()
 * DESCRIPTION:	handle the < > <= >= operators
 */
static node *rel(int op, node *n1, node *n2, char *name)
{
    char tnbuf1[TNBUFSIZE], tnbuf2[TNBUFSIZE];

    t_void(n1);
    t_void(n2);

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i . i */
	switch (op) {
	case N_GE:
	    n1->l.number = (n1->l.number >= n2->l.number);
	    break;

	case N_GT:
	    n1->l.number = (n1->l.number > n2->l.number);
	    break;

	case N_LE:
	    n1->l.number = (n1->l.number <= n2->l.number);
	    break;

	case N_LT:
	    n1->l.number = (n1->l.number < n2->l.number);
	    break;
	}
	return n1;
    }
    if (n1->type == N_FLOAT && n2->type == N_FLOAT) {
	xfloat f1, f2;

	/* f . f */
	NFLT_GET(n1, f1);
	NFLT_GET(n2, f2);

	switch (op) {
	case N_GE:
	    return node_int((Int) (flt_cmp(&f1, &f2) >= 0));

	case N_GT:
	    return node_int((Int) (flt_cmp(&f1, &f2) > 0));

	case N_LE:
	    return node_int((Int) (flt_cmp(&f1, &f2) <= 0));

	case N_LT:
	    return node_int((Int) (flt_cmp(&f1, &f2) < 0));
	}
	return n1;
    }
    if (n1->type == N_STR && n2->type == N_STR) {
	/* s . s */
	switch (op) {
	case N_GE:
	    return node_int((Int) (str_cmp(n1->l.string, n2->l.string) >= 0));

	case N_GT:
	    return node_int((Int) (str_cmp(n1->l.string, n2->l.string) > 0));

	case N_LE:
	    return node_int((Int) (str_cmp(n1->l.string, n2->l.string) <= 0));

	case N_LT:
	    return node_int((Int) (str_cmp(n1->l.string, n2->l.string) < 0));
	}
    }

    if (n1->mod != T_OBJECT && n1->mod != T_CLASS && n1->mod != T_MIXED &&
	typechecking &&
	((n1->mod != n2->mod && n2->mod != T_MIXED) || !T_ARITHSTR(n1->mod) ||
	 (!T_ARITHSTR(n2->mod) && n2->mod != T_MIXED))) {
	c_error("bad argument types for %s (%s, %s)", name,
		i_typename(tnbuf1, n1->mod), i_typename(tnbuf2, n2->mod));
    } else if (n1->mod == T_INT && n2->mod == T_INT) {
	op++;
    }
    return node_bin(op, T_INT, n1, n2);
}

/*
 * NAME:	eq()
 * DESCRIPTION:	handle the == operator
 */
static node *eq(node *n1, node *n2)
{
    char tnbuf1[TNBUFSIZE], tnbuf2[TNBUFSIZE];
    xfloat f1, f2;
    int op;

    t_void(n1);
    t_void(n2);

    switch (n1->type) {
    case N_INT:
	if (n2->type == N_INT) {
	    /* i == i */
	    n1->l.number = (n1->l.number == n2->l.number);
	    return n1;
	}
	if (nil_node == N_INT && n1->l.number == 0 && n2->type == N_STR) {
	    /* nil == str */
	    return node_int((Int) FALSE);
	}
	break;

    case N_FLOAT:
	if (n2->type == N_FLOAT) {
	    /* f == f */
	    NFLT_GET(n1, f1);
	    NFLT_GET(n2, f2);
	    return node_int((Int) (flt_cmp(&f1, &f2) == 0));
	}
	break;

    case N_STR:
	if (n2->type == N_STR) {
	    /* s == s */
	    return node_int((Int) (str_cmp(n1->l.string, n2->l.string) == 0));
	}
	if (n2->type == nil_node && n2->l.number == 0) {
	    /* s == nil */
	    return node_int((Int) FALSE);
	}
	break;

    case N_NIL:
	if (n2->type == N_NIL) {
	    /* nil == nil */
	    return node_int((Int) TRUE);
	}
	if (n2->type == N_STR) {
	    /* nil == str */
	    return node_int((Int) FALSE);
	}
	break;
    }

    op = N_EQ;
    if (c_tmatch(n1->mod, n2->mod) == T_NIL &&
	(!c_nil(n1) || !T_POINTER(n2->mod)) &&
	(!c_nil(n2) || !T_POINTER(n1->mod))) {
	if (typechecking) {
	    c_error("incompatible types for equality (%s, %s)",
		    i_typename(tnbuf1, n1->mod), i_typename(tnbuf2, n2->mod));
	}
    } else if (n1->mod == T_INT && n2->mod == T_INT) {
	op++;
    }
    return node_bin(op, T_INT, n1, n2);
}

/*
 * NAME:	and()
 * DESCRIPTION:	handle the & &= operators
 */
static node *and(int op, node *n1, node *n2, char *name)
{
    unsigned short type;

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i & i */
	n1->l.number &= n2->l.number;
	return n1;
    }
    if ((((type=n1->mod) == T_MIXED || type == T_MAPPING) &&
	 ((n2->mod & T_REF) != 0 || n2->mod == T_MIXED)) ||
	((type=c_tmatch(n1->mod, n2->mod)) & T_REF) != T_NIL) {
	/*
	 * possibly array & array or mapping & array
	 */
	return node_bin(op, type, n1, n2);
    }
    return bini(op, n1, n2, name);
}

/*
 * NAME:	xor()
 * DESCRIPTION:	handle the ^ ^= operators
 */
static node *xor(int op, node *n1, node *n2, char *name)
{
    unsigned short type;

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i ^ i */
	n1->l.number ^= n2->l.number;
	return n1;
    }
    if (((type=n1->mod) == T_MIXED && n2->mod == T_MIXED) ||
	((type=c_tmatch(n1->mod, n2->mod)) & T_REF) != T_NIL) {
	/*
	 * possibly array ^ array
	 */
	return node_bin(op, type, n1, n2);
    }
    return bini(op, n1, n2, name);
}

/*
 * NAME:	or()
 * DESCRIPTION:	handle the | |= operators
 */
static node *or(int op, node *n1, node *n2, char *name)
{
    unsigned short type;

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i | i */
	n1->l.number |= n2->l.number;
	return n1;
    }
    if (((type=n1->mod) == T_MIXED && n2->mod == T_MIXED) ||
	((type=c_tmatch(n1->mod, n2->mod)) & T_REF) != T_NIL) {
	/*
	 * possibly array | array
	 */
	return node_bin(op, type, n1, n2);
    }
    return bini(op, n1, n2, name);
}

/*
 * NAME:	land()
 * DESCRIPTION:	handle the && operator
 */
static node *land(node *n1, node *n2)
{
    t_void(n1);
    t_void(n2);

    if ((n1->flags & F_CONST) && (n2->flags & F_CONST)) {
	n1 = c_tst(n1);
	n2 = c_tst(n2);
	n1->l.number &= n2->l.number;
	return n1;
    }

    return node_bin(N_LAND, T_INT, n1, n2);
}

/*
 * NAME:	lor()
 * DESCRIPTION:	handle the || operator
 */
static node *lor(node *n1, node *n2)
{
    t_void(n1);
    t_void(n2);

    if ((n1->flags & F_CONST) && (n2->flags & F_CONST)) {
	n1 = c_tst(n1);
	n2 = c_tst(n2);
	n1->l.number |= n2->l.number;
	return n1;
    }

    return node_bin(N_LOR, T_INT, n1, n2);
}

/*
 * NAME:	quest()
 * DESCRIPTION:	handle the ? : operator
 */
static node *quest(node *n1, node *n2, node *n3)
{
    unsigned short type;

    t_void(n1);

    if ((n2->flags & F_CONST) && n3->type == n2->type) {
	switch (n1->type) {
	case N_INT:
	    return (n1->l.number == 0) ? n3 : n2;

	case N_FLOAT:
	    return (NFLT_ISZERO(n1)) ? n3 : n2;

	case N_STR:
	    return n2;

	case N_NIL:
	    return n3;
	}
    }

    type = T_MIXED;
    if (c_nil(n2) && T_POINTER(n3->mod)) {
	/*
	 * expr ? nil : expr
	 */
	type = n3->mod;
    } else if (c_nil(n3) && T_POINTER(n2->mod)) {
	/*
	 * expr ? expr : nil;
	 */
	type = n2->mod;
    } else if (typechecking) {
	/*
	 * typechecked
	 */
	if (n2->mod == T_VOID || n3->mod == T_VOID) {
	    /* result can never be used */
	    type = T_VOID;
	} else {
	    type = c_tmatch(n2->mod, n3->mod);
	    if (type == T_NIL) {
		/* no typechecking here, just let the result be mixed */
		type = T_MIXED;
	    }
	}
    }

    n1 = node_bin(N_QUEST, type, n1, node_bin(N_PAIR, 0, n2, n3));
    if ((type & T_TYPE) == T_CLASS) {
	if (n2->class == (string *) NULL) {
	    n1->class = n3->class;
	} else if (n3->class == (string *) NULL ||
		   str_cmp(n2->class, n3->class) == 0) {
	    n1->class = n2->class;
	} else {
	    /* downgrade to object */
	    n1->type = (n1->type & T_REF) | T_OBJECT;
	}
    }
    return n1;
}

/*
 * NAME:	assign()
 * DESCRIPTION:	handle the assignment operator
 */
static node *assign(node *n1, node *n2)
{
    char tnbuf1[TNBUFSIZE], tnbuf2[TNBUFSIZE];
    node *n, *m;
    unsigned short type;

    if (n1->type == N_AGGR) {
	/*
	 * ({ a, b }) = array;
	 */
	if (typechecking) {
	    type = n2->mod;
	    if ((n2->mod & T_REF) != 0) {
		type -= 1 << REFSHIFT;
		if (type != T_MIXED) {
		    n = node_mon(N_TYPE, type, (node *) NULL);
		    n->class = n2->class;
		    n1->r.right = n;
		}
	    } else if (type != T_MIXED) {
		c_error("incompatible types for = (%s, %s)",
			i_typename(tnbuf1, n1->mod),
			i_typename(tnbuf2, type));
		type = T_MIXED;
	    }

	    n = n1->l.left;
	    while (n != (node *) NULL) {
		if (n->type == N_PAIR) {
		    m = n->l.left;
		    n = n->r.right;
		} else {
		    m = n;
		    n = (node *) NULL;
		}
		if (c_tmatch(m->mod, type) == T_NIL) {
		    c_error("incompatible types for = (%s, %s)",
			    i_typename(tnbuf1, m->mod),
			    i_typename(tnbuf2, type));
		}
	    }
	}
	n1 = node_bin(N_ASSIGN, n2->mod, n1, n2);
	n1->class = n2->class;
	return n1;
    } else {
	if (typechecking && (!c_nil(n2) || !T_POINTER(n1->mod))) {
	    /*
	     * typechecked
	     */
	    if (c_tmatch(n1->mod, n2->mod) == T_NIL) {
		c_error("incompatible types for = (%s, %s)",
			i_typename(tnbuf1, n1->mod),
			i_typename(tnbuf2, n2->mod));
	    } else if ((n1->mod != T_MIXED && n2->mod == T_MIXED) ||
		       (n1->mod == T_CLASS &&
			(n2->mod != T_CLASS ||
			 str_cmp(n1->class, n2->class) != 0))) {
		n2 = node_mon(N_CAST, n1->mod, n2);
		n2->class = n1->class;
	    }
	}

	n2 = node_bin(N_ASSIGN, n1->mod, n1, n2);
	n2->class = n1->class;
	return n2;
    }
}

/*
 * NAME:	comma()
 * DESCRIPTION:	handle the comma operator, rearranging the order of the
 *		expression if needed
 */
static node *comma(node *n1, node *n2)
{
    if (n2->type == N_COMMA) {
	/* a, (b, c) --> (a, b), c */
	n2->l.left = comma(n1, n2->l.left);
	return n2;
    } else {
	n1 = node_bin(N_COMMA, n2->mod, n1, n2);
	n1->class = n2->class;
	return n1;
    }
}
#line 2285 "y.tab.c"
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yysslim)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yysslim)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
#line 132 "parser.y"
{
		  nerrors = 0;
		  ndeclarations = 0;
		}
break;
case 2:
#line 137 "parser.y"
{
		  if (nerrors > 0) {
		      YYABORT;
		  }
		}
break;
case 4:
#line 147 "parser.y"
{
		  if (nerrors > 0) {
		      YYABORT;
		  }
		}
break;
case 5:
#line 156 "parser.y"
{
		  if (ndeclarations > 0) {
		      c_error("inherit must precede all declarations");
		  } else if (nerrors > 0 ||
			     !c_inherit(yyvsp[-1].node->l.string->text, yyvsp[-3].node, yyvsp[-5].type != 0)) {
		      /*
		       * The object to be inherited may have been compiled;
		       * abort this compilation and possibly restart later.
		       */
		      YYABORT;
		  }
		}
break;
case 6:
#line 169 "parser.y"
{ ndeclarations++; }
break;
case 7:
#line 171 "parser.y"
{ ndeclarations++; }
break;
case 8:
#line 176 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 10:
#line 182 "parser.y"
{ yyval.node = node_str(str_new(yytext, (long) yyleng)); }
break;
case 12:
#line 188 "parser.y"
{ yyval.node = node_str(str_add(yyvsp[-2].node->l.string, yyvsp[0].node->l.string)); }
break;
case 13:
#line 190 "parser.y"
{ yyval.node = yyvsp[-1].node; }
break;
case 14:
#line 195 "parser.y"
{ yyval.node = node_str(str_new(yytext, (long) yyleng)); }
break;
case 15:
#line 200 "parser.y"
{ c_global(yyvsp[-3].type, yyvsp[-2].node, yyvsp[-1].node); }
break;
case 16:
#line 205 "parser.y"
{
		  typechecking = TRUE;
		  c_function(yyvsp[-2].type, yyvsp[-1].node, yyvsp[0].node);
		}
break;
case 17:
#line 210 "parser.y"
{
		  if (nerrors == 0) {
		      c_funcbody(yyvsp[0].node);
		  }
		}
break;
case 18:
#line 216 "parser.y"
{
		  typechecking = c_typechecking();
		  c_function(yyvsp[-4].type, node_type((typechecking) ? T_VOID : T_NIL,
					   (string *) NULL),
			     node_bin(N_FUNC, 0, yyvsp[-3].node, yyvsp[-1].node));
		}
break;
case 19:
#line 223 "parser.y"
{
		  if (nerrors == 0) {
		      c_funcbody(yyvsp[0].node);
		  }
		}
break;
case 20:
#line 232 "parser.y"
{ c_local(yyvsp[-3].type, yyvsp[-2].node, yyvsp[-1].node); }
break;
case 21:
#line 237 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 22:
#line 238 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 24:
#line 241 "parser.y"
{
		  yyval.node = yyvsp[-1].node;
		  yyval.node->flags |= F_ELLIPSIS;
		}
break;
case 26:
#line 250 "parser.y"
{ yyval.node = node_bin(N_PAIR, 0, yyvsp[-2].node, yyvsp[0].node); }
break;
case 27:
#line 255 "parser.y"
{
		  yyval.node = yyvsp[0].node;
		  yyval.node->flags |= F_VARARGS;
		}
break;
case 29:
#line 264 "parser.y"
{
		  yyval.node = yyvsp[0].node;
		  yyval.node->mod |= yyvsp[-1].node->mod;
		  yyval.node->class = yyvsp[-1].node->class;
		}
break;
case 30:
#line 269 "parser.y"
{
		  yyval.node = yyvsp[0].node;
		  yyval.node->mod = T_NIL;	/* only if typechecking, though */
		}
break;
case 33:
#line 279 "parser.y"
{ yyval.type = yyvsp[-1].type | yyvsp[0].type; }
break;
case 35:
#line 285 "parser.y"
{ yyval.type = yyvsp[-1].type | yyvsp[0].type; }
break;
case 36:
#line 290 "parser.y"
{ yyval.type = C_STATIC | C_PRIVATE; }
break;
case 38:
#line 296 "parser.y"
{ yyval.type = 0; }
break;
case 39:
#line 298 "parser.y"
{ yyval.type = C_STATIC | C_PRIVATE; }
break;
case 40:
#line 303 "parser.y"
{ yyval.type = C_STATIC; }
break;
case 41:
#line 305 "parser.y"
{ yyval.type = C_ATOMIC; }
break;
case 42:
#line 307 "parser.y"
{ yyval.type = C_NOMASK; }
break;
case 43:
#line 309 "parser.y"
{ yyval.type = C_VARARGS; }
break;
case 44:
#line 313 "parser.y"
{ yyval.node = node_type(T_INT, (string *) NULL); }
break;
case 45:
#line 314 "parser.y"
{ yyval.node = node_type(T_FLOAT, (string *) NULL); }
break;
case 46:
#line 316 "parser.y"
{ yyval.node = node_type(T_STRING, (string *) NULL); }
break;
case 47:
#line 318 "parser.y"
{ yyval.node = node_type(T_OBJECT, (string *) NULL); }
break;
case 48:
#line 320 "parser.y"
{ yyval.node = node_type(T_CLASS, c_objecttype(yyvsp[0].node)); }
break;
case 49:
#line 322 "parser.y"
{ yyval.node = node_type(T_MAPPING, (string *) NULL); }
break;
case 50:
#line 324 "parser.y"
{
		  yyval.node = node_str(str_new("/" BIPREFIX "function",
					BIPREFIXLEN + 9));
		  yyval.node = node_type(T_CLASS, c_objecttype(yyval.node));
		}
break;
case 51:
#line 329 "parser.y"
{ yyval.node = node_type(T_MIXED, (string *) NULL); }
break;
case 52:
#line 330 "parser.y"
{ yyval.node = node_type(T_VOID, (string *) NULL); }
break;
case 55:
#line 340 "parser.y"
{ yyval.type = 0; }
break;
case 56:
#line 342 "parser.y"
{
		  yyval.type = yyvsp[-1].type + 1;
		  if (yyval.type == 1 << (8 - REFSHIFT)) {
		      c_error("too deep indirection");
		  }
		}
break;
case 57:
#line 352 "parser.y"
{
		  yyval.node = yyvsp[0].node;
		  yyval.node->mod = (yyvsp[-1].type << REFSHIFT) & T_REF;
		}
break;
case 58:
#line 360 "parser.y"
{ yyval.node = node_op("+"); }
break;
case 59:
#line 362 "parser.y"
{ yyval.node = node_op("-"); }
break;
case 60:
#line 364 "parser.y"
{ yyval.node = node_op("*"); }
break;
case 61:
#line 366 "parser.y"
{ yyval.node = node_op("/"); }
break;
case 62:
#line 368 "parser.y"
{ yyval.node = node_op("%"); }
break;
case 63:
#line 370 "parser.y"
{ yyval.node = node_op("&"); }
break;
case 64:
#line 372 "parser.y"
{ yyval.node = node_op("^"); }
break;
case 65:
#line 374 "parser.y"
{ yyval.node = node_op("|"); }
break;
case 66:
#line 376 "parser.y"
{ yyval.node = node_op("<"); }
break;
case 67:
#line 378 "parser.y"
{ yyval.node = node_op(">"); }
break;
case 68:
#line 380 "parser.y"
{ yyval.node = node_op("<="); }
break;
case 69:
#line 382 "parser.y"
{ yyval.node = node_op(">="); }
break;
case 70:
#line 384 "parser.y"
{ yyval.node = node_op("<<"); }
break;
case 71:
#line 386 "parser.y"
{ yyval.node = node_op(">>"); }
break;
case 72:
#line 388 "parser.y"
{ yyval.node = node_op("~"); }
break;
case 73:
#line 390 "parser.y"
{ yyval.node = node_op("++"); }
break;
case 74:
#line 392 "parser.y"
{ yyval.node = node_op("--"); }
break;
case 75:
#line 394 "parser.y"
{ yyval.node = node_op("[]"); }
break;
case 76:
#line 396 "parser.y"
{ yyval.node = node_op("[]="); }
break;
case 77:
#line 398 "parser.y"
{ yyval.node = node_op("[..]"); }
break;
case 80:
#line 408 "parser.y"
{ yyval.node = node_bin(N_FUNC, (yyvsp[-4].type << REFSHIFT) & T_REF, yyvsp[-3].node, yyvsp[-1].node); }
break;
case 84:
#line 419 "parser.y"
{ yyval.node = node_bin(N_PAIR, 0, yyvsp[-2].node, yyvsp[0].node); }
break;
case 85:
#line 424 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 86:
#line 426 "parser.y"
{ yyval.node = c_concat(yyvsp[-1].node, yyvsp[0].node); }
break;
case 87:
#line 431 "parser.y"
{
		  if (nstatements > 0) {
		      c_error("declaration after statement");
		  }
		  yyval.node = (node *) NULL;
		}
break;
case 88:
#line 437 "parser.y"
{
		  nstatements++;
		  yyval.node = yyvsp[0].node;
		}
break;
case 89:
#line 442 "parser.y"
{
		  if (nerrors >= MAX_ERRORS) {
		      YYABORT;
		  }
		  yyval.node = (node *) NULL;
		}
break;
case 90:
#line 452 "parser.y"
{ c_startcond(); }
break;
case 91:
#line 453 "parser.y"
{ yyval.node = c_if(yyvsp[-3].node, yyvsp[0].node); }
break;
case 92:
#line 458 "parser.y"
{ yyval.node = c_exp_stmt(yyvsp[-1].node); }
break;
case 94:
#line 461 "parser.y"
{
		  c_endcond();
		  yyval.node = c_endif(yyvsp[0].node, (node *) NULL);
		}
break;
case 95:
#line 467 "parser.y"
{ c_startcond2(); }
break;
case 96:
#line 469 "parser.y"
{
		  c_matchcond();
		  yyval.node = c_endif(yyvsp[-3].node, yyvsp[0].node);
		}
break;
case 97:
#line 473 "parser.y"
{ c_loop(); }
break;
case 98:
#line 475 "parser.y"
{ yyval.node = c_do(yyvsp[-2].node, yyvsp[-5].node); }
break;
case 99:
#line 477 "parser.y"
{
		  c_loop();
		  c_startcond();
		}
break;
case 100:
#line 481 "parser.y"
{
		  c_endcond();
		  yyval.node = c_while(yyvsp[-3].node, yyvsp[0].node);
		}
break;
case 101:
#line 486 "parser.y"
{
		  c_loop();
		  c_startcond();
		}
break;
case 102:
#line 490 "parser.y"
{
		  c_endcond();
		  yyval.node = c_for(c_exp_stmt(yyvsp[-7].node), yyvsp[-5].node, c_exp_stmt(yyvsp[-3].node), yyvsp[0].node);
		}
break;
case 103:
#line 495 "parser.y"
{
		  if (typechecking) {
		      char tnbuf[TNBUFSIZE];

		      if (yyvsp[-3].node->mod != T_INT && yyvsp[-3].node->mod != T_MIXED) {
			  c_error("bad type for stack rlimit (%s)",
				  i_typename(tnbuf, yyvsp[-3].node->mod));
		      }
		      if (yyvsp[-1].node->mod != T_INT && yyvsp[-1].node->mod != T_MIXED) {
			  c_error("bad type for ticks rlimit (%s)",
				  i_typename(tnbuf, yyvsp[-1].node->mod));
		      }
		  }
		  c_startrlimits();
		}
break;
case 104:
#line 511 "parser.y"
{ yyval.node = c_endrlimits(yyvsp[-5].node, yyvsp[-3].node, yyvsp[0].node); }
break;
case 105:
#line 512 "parser.y"
{
		  c_startcatch();
		  c_startcond();
		}
break;
case 106:
#line 517 "parser.y"
{
		  c_endcond();
		  c_endcatch();
		  c_startcond();
		}
break;
case 107:
#line 523 "parser.y"
{
		  c_endcond();
		  yyval.node = c_donecatch(yyvsp[-2].node, yyvsp[0].node);
		}
break;
case 108:
#line 528 "parser.y"
{
		  c_startswitch(yyvsp[-1].node, typechecking);
		  c_startcond();
		}
break;
case 109:
#line 533 "parser.y"
{
		  c_endcond();
		  yyval.node = c_endswitch(yyvsp[-3].node, yyvsp[0].node);
		}
break;
case 110:
#line 538 "parser.y"
{ yyvsp[-1].node = c_case(yyvsp[-1].node, (node *) NULL); }
break;
case 111:
#line 539 "parser.y"
{
		  yyval.node = yyvsp[-3].node;
		  if (yyval.node != (node *) NULL) {
		      yyval.node->l.left = yyvsp[0].node;
		  } else {
		      yyval.node = yyvsp[0].node;
		  }
		}
break;
case 112:
#line 548 "parser.y"
{ yyvsp[-3].node = c_case(yyvsp[-3].node, yyvsp[-1].node); }
break;
case 113:
#line 549 "parser.y"
{
		  yyval.node = yyvsp[-5].node;
		  if (yyval.node != (node *) NULL) {
		      yyval.node->l.left = yyvsp[0].node;
		  } else {
		      yyval.node = yyvsp[0].node;
		  }
		}
break;
case 114:
#line 558 "parser.y"
{ yyvsp[0].node = c_default(); }
break;
case 115:
#line 559 "parser.y"
{
		  yyval.node = yyvsp[-2].node;
		  if (yyval.node != (node *) NULL) {
		      yyval.node->l.left = yyvsp[0].node;
		  } else {
		      yyval.node = yyvsp[0].node;
		  }
		}
break;
case 116:
#line 568 "parser.y"
{ yyvsp[0].node = c_label(yyvsp[-1].node); }
break;
case 117:
#line 569 "parser.y"
{ yyval.node = c_concat(yyvsp[-2].node, yyvsp[0].node); }
break;
case 118:
#line 571 "parser.y"
{
		  yyval.node = c_goto(yyvsp[-1].node);
		}
break;
case 119:
#line 575 "parser.y"
{
		  yyval.node = c_break();
		}
break;
case 120:
#line 579 "parser.y"
{
		  yyval.node = c_continue();
		}
break;
case 121:
#line 583 "parser.y"
{ yyval.node = c_return(yyvsp[-1].node, typechecking); }
break;
case 122:
#line 584 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 123:
#line 588 "parser.y"
{
		  nstatements = 0;
		  c_startcompound();
		}
break;
case 124:
#line 593 "parser.y"
{
		  nstatements++;
		  yyval.node = c_endcompound(yyvsp[-1].node);
		}
break;
case 125:
#line 601 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 126:
#line 603 "parser.y"
{ yyval.node = yyvsp[0].node; }
break;
case 127:
#line 608 "parser.y"
{ yyval.node = c_flookup(yyvsp[0].node, typechecking); }
break;
case 128:
#line 610 "parser.y"
{ yyval.node = c_iflookup(yyvsp[0].node, (node *) NULL); }
break;
case 129:
#line 612 "parser.y"
{ yyval.node = c_iflookup(yyvsp[0].node, yyvsp[-2].node); }
break;
case 130:
#line 617 "parser.y"
{ yyval.node = node_int(yyvsp[0].number); }
break;
case 131:
#line 619 "parser.y"
{ yyval.node = node_float(&yyvsp[0].real); }
break;
case 132:
#line 620 "parser.y"
{ yyval.node = node_nil(); }
break;
case 134:
#line 623 "parser.y"
{ yyval.node = c_aggregate(yyvsp[-2].node, T_MIXED | (1 << REFSHIFT)); }
break;
case 135:
#line 625 "parser.y"
{ yyval.node = c_aggregate(yyvsp[-2].node, T_MAPPING); }
break;
case 136:
#line 626 "parser.y"
{
		  yyval.node = c_variable(yyvsp[0].node);
		  if (typechecking) {
		      if (yyval.node->type == N_GLOBAL && yyval.node->mod != T_MIXED &&
			  !conf_typechecking()) {
			  /*
			   * global vars might be modified by untypechecked
			   * functions...
			   */
			  yyval.node = node_mon(N_CAST, yyval.node->mod, yyval.node);
			  yyval.node->class = yyval.node->l.left->class;
		      }
		  } else {
		      /* the variable could be anything */
		      yyval.node->mod = T_MIXED;
		  }
		}
break;
case 137:
#line 644 "parser.y"
{ yyval.node = yyvsp[-1].node; }
break;
case 138:
#line 646 "parser.y"
{ yyval.node = c_checkcall(c_funcall(yyvsp[-3].node, yyvsp[-1].node), typechecking); }
break;
case 139:
#line 648 "parser.y"
{ yyval.node = c_address(yyvsp[-3].node, yyvsp[-1].node, typechecking); }
break;
case 140:
#line 650 "parser.y"
{ yyval.node = c_extend(yyvsp[-4].node, yyvsp[-1].node, typechecking); }
break;
case 141:
#line 652 "parser.y"
{ yyval.node = c_call(yyvsp[-4].node, yyvsp[-1].node, typechecking); }
break;
case 142:
#line 654 "parser.y"
{ c_startcond(); }
break;
case 143:
#line 656 "parser.y"
{
		  c_endcond();
		  yyval.node = node_mon(N_CATCH, T_STRING, yyvsp[-1].node);
		}
break;
case 144:
#line 661 "parser.y"
{ yyval.node = c_new_object(yyvsp[0].node, (node *) NULL); }
break;
case 145:
#line 663 "parser.y"
{ yyval.node = c_new_object(yyvsp[-1].node, (node *) NULL); }
break;
case 146:
#line 665 "parser.y"
{ yyval.node = c_new_object(yyvsp[-3].node, yyvsp[-1].node); }
break;
case 147:
#line 667 "parser.y"
{ yyval.node = c_new_object(yyvsp[-4].node, yyvsp[-1].node); }
break;
case 148:
#line 669 "parser.y"
{
		  t_void(yyvsp[-5].node);
		  yyval.node = c_checkcall(c_arrow(yyvsp[-5].node, yyvsp[-3].node, yyvsp[-1].node), typechecking);
		}
break;
case 149:
#line 674 "parser.y"
{ yyval.node = c_instanceof(yyvsp[-3].node, yyvsp[0].node); }
break;
case 150:
#line 676 "parser.y"
{ yyval.node = c_instanceof(yyvsp[-5].node, yyvsp[-1].node); }
break;
case 152:
#line 682 "parser.y"
{ yyval.node = idx(yyvsp[-3].node, yyvsp[-1].node); }
break;
case 153:
#line 684 "parser.y"
{ yyval.node = range(yyvsp[-5].node, yyvsp[-3].node, yyvsp[-1].node); }
break;
case 155:
#line 690 "parser.y"
{ yyval.node = postfix(N_PLUS_PLUS, yyvsp[-1].node, "++"); }
break;
case 156:
#line 692 "parser.y"
{ yyval.node = postfix(N_MIN_MIN, yyvsp[-1].node, "--"); }
break;
case 158:
#line 698 "parser.y"
{ yyval.node = prefix(N_ADD_EQ_1, yyvsp[0].node, "++"); }
break;
case 159:
#line 700 "parser.y"
{ yyval.node = prefix(N_SUB_EQ_1, yyvsp[0].node, "--"); }
break;
case 160:
#line 702 "parser.y"
{ yyval.node = umin(yyvsp[0].node); }
break;
case 161:
#line 704 "parser.y"
{ yyval.node = yyvsp[0].node; }
break;
case 162:
#line 706 "parser.y"
{
		  t_void(yyvsp[0].node);
		  yyval.node = c_not(yyvsp[0].node);
		}
break;
case 163:
#line 711 "parser.y"
{
		  yyval.node = yyvsp[0].node;
		  t_void(yyval.node);
		  if (yyval.node->mod == T_INT) {
		      yyval.node = xor(N_XOR, yyval.node, node_int((Int) -1), "^");
		  } else if (yyval.node->mod == T_OBJECT || yyval.node->mod == T_CLASS) {
		      yyval.node = node_mon(N_NEG, T_OBJECT, yyval.node);
		  } else {
		      if (typechecking && yyval.node->mod != T_MIXED) {
			  char tnbuf[TNBUFSIZE];

			  c_error("bad argument type for ~ (%s)",
				  i_typename(tnbuf, yyval.node->mod));
		      }
		      yyval.node = node_mon(N_NEG, T_MIXED, yyval.node);
		  }
		}
break;
case 165:
#line 733 "parser.y"
{
		  yyvsp[-3].node->mod |= (yyvsp[-2].type << REFSHIFT) & T_REF;
		  yyval.node = cast(yyvsp[0].node, yyvsp[-3].node);
		}
break;
case 167:
#line 742 "parser.y"
{ yyval.node = mult(N_MULT, yyvsp[-2].node, yyvsp[0].node, "*"); }
break;
case 168:
#line 744 "parser.y"
{ yyval.node = mdiv(N_DIV, yyvsp[-2].node, yyvsp[0].node, "/"); }
break;
case 169:
#line 746 "parser.y"
{ yyval.node = mod(N_MOD, yyvsp[-2].node, yyvsp[0].node, "%"); }
break;
case 171:
#line 752 "parser.y"
{ yyval.node = add(N_ADD, yyvsp[-2].node, yyvsp[0].node, "+"); }
break;
case 172:
#line 754 "parser.y"
{ yyval.node = sub(N_SUB, yyvsp[-2].node, yyvsp[0].node, "-"); }
break;
case 174:
#line 760 "parser.y"
{ yyval.node = lshift(N_LSHIFT, yyvsp[-2].node, yyvsp[0].node, "<<"); }
break;
case 175:
#line 762 "parser.y"
{ yyval.node = rshift(N_RSHIFT, yyvsp[-2].node, yyvsp[0].node, ">>"); }
break;
case 177:
#line 768 "parser.y"
{ yyval.node = rel(N_LT, yyval.node, yyvsp[0].node, "<"); }
break;
case 178:
#line 770 "parser.y"
{ yyval.node = rel(N_GT, yyval.node, yyvsp[0].node, ">"); }
break;
case 179:
#line 772 "parser.y"
{ yyval.node = rel(N_LE, yyval.node, yyvsp[0].node, "<="); }
break;
case 180:
#line 774 "parser.y"
{ yyval.node = rel(N_GE, yyval.node, yyvsp[0].node, ">="); }
break;
case 182:
#line 780 "parser.y"
{ yyval.node = eq(yyvsp[-2].node, yyvsp[0].node); }
break;
case 183:
#line 782 "parser.y"
{ yyval.node = c_not(eq(yyvsp[-2].node, yyvsp[0].node)); }
break;
case 185:
#line 788 "parser.y"
{ yyval.node = and(N_AND, yyvsp[-2].node, yyvsp[0].node, "&"); }
break;
case 187:
#line 794 "parser.y"
{ yyval.node = xor(N_XOR, yyvsp[-2].node, yyvsp[0].node, "^"); }
break;
case 189:
#line 800 "parser.y"
{ yyval.node = or(N_OR, yyvsp[-2].node, yyvsp[0].node, "|"); }
break;
case 191:
#line 806 "parser.y"
{ yyval.node = land(yyvsp[-2].node, yyvsp[0].node); }
break;
case 193:
#line 812 "parser.y"
{ yyval.node = lor(yyvsp[-2].node, yyvsp[0].node); }
break;
case 195:
#line 818 "parser.y"
{ c_startcond(); }
break;
case 196:
#line 820 "parser.y"
{ c_startcond2(); }
break;
case 197:
#line 822 "parser.y"
{
		  c_matchcond();
		  yyval.node = quest(yyvsp[-6].node, yyvsp[-3].node, yyvsp[0].node);
		}
break;
case 199:
#line 831 "parser.y"
{ yyval.node = assign(c_assign(yyvsp[-2].node), yyvsp[0].node); }
break;
case 200:
#line 833 "parser.y"
{ yyval.node = add(N_ADD_EQ, c_lvalue(yyvsp[-2].node, "+="), yyvsp[0].node, "+="); }
break;
case 201:
#line 835 "parser.y"
{ yyval.node = sub(N_SUB_EQ, c_lvalue(yyvsp[-2].node, "-="), yyvsp[0].node, "-="); }
break;
case 202:
#line 837 "parser.y"
{ yyval.node = mult(N_MULT_EQ, c_lvalue(yyvsp[-2].node, "*="), yyvsp[0].node, "*="); }
break;
case 203:
#line 839 "parser.y"
{ yyval.node = mdiv(N_DIV_EQ, c_lvalue(yyvsp[-2].node, "/="), yyvsp[0].node, "/="); }
break;
case 204:
#line 841 "parser.y"
{ yyval.node = mod(N_MOD_EQ, c_lvalue(yyvsp[-2].node, "%="), yyvsp[0].node, "%="); }
break;
case 205:
#line 843 "parser.y"
{ yyval.node = lshift(N_LSHIFT_EQ, c_lvalue(yyvsp[-2].node, "<<="), yyvsp[0].node, "<<="); }
break;
case 206:
#line 845 "parser.y"
{ yyval.node = rshift(N_RSHIFT_EQ, c_lvalue(yyvsp[-2].node, ">>="), yyvsp[0].node, ">>="); }
break;
case 207:
#line 847 "parser.y"
{ yyval.node = and(N_AND_EQ, c_lvalue(yyvsp[-2].node, "&="), yyvsp[0].node, "&="); }
break;
case 208:
#line 849 "parser.y"
{ yyval.node = xor(N_XOR_EQ, c_lvalue(yyvsp[-2].node, "^="), yyvsp[0].node, "^="); }
break;
case 209:
#line 851 "parser.y"
{ yyval.node = or(N_OR_EQ, c_lvalue(yyvsp[-2].node, "|="), yyvsp[0].node, "|="); }
break;
case 211:
#line 857 "parser.y"
{ yyval.node = comma(yyvsp[-2].node, yyvsp[0].node); }
break;
case 212:
#line 862 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 214:
#line 868 "parser.y"
{ t_void(yyval.node = yyvsp[0].node); }
break;
case 215:
#line 873 "parser.y"
{ t_void(yyval.node = yyvsp[0].node); }
break;
case 216:
#line 877 "parser.y"
{ t_void(yyval.node = yyvsp[0].node); }
break;
case 217:
#line 879 "parser.y"
{
		  t_void(yyvsp[0].node);
		  yyval.node = node_bin(N_PAIR, 0, yyvsp[-2].node, yyvsp[0].node);
		}
break;
case 218:
#line 887 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 220:
#line 890 "parser.y"
{
		  yyval.node = yyvsp[-1].node;
		  if (yyval.node->type == N_PAIR) {
		      yyval.node->r.right = node_mon(N_SPREAD, -1, yyval.node->r.right);
		  } else {
		      yyval.node = node_mon(N_SPREAD, -1, yyval.node);
		  }
		}
break;
case 221:
#line 902 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 223:
#line 905 "parser.y"
{ yyval.node = yyvsp[-1].node; }
break;
case 224:
#line 910 "parser.y"
{
		  t_void(yyvsp[-2].node);
		  t_void(yyvsp[0].node);
		  yyval.node = node_bin(N_COMMA, 0, yyvsp[-2].node, yyvsp[0].node);
		}
break;
case 226:
#line 920 "parser.y"
{ yyval.node = node_bin(N_PAIR, 0, yyvsp[-2].node, yyvsp[0].node); }
break;
case 227:
#line 925 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 229:
#line 928 "parser.y"
{ yyval.node = yyvsp[-1].node; }
break;
#line 3395 "y.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yysslim)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
